import type { Express, RequestHandler } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { z } from "zod";
import { insertBoxSchema, insertItemSchema, insertFairnessProofSchema, type BoxOpeningResult, partners, apiUsage, partnerBoxes, whitelabelSites, insertWhitelabelSiteSchema, type WhitelabelSite } from "@shared/schema";
import { whitelabelManager } from "./whitelabel-manager";
import { setupAuth, isAuthenticated } from "./replitAuth";
import { FairnessSystem } from "./fairness";
import { db } from "./db";
import { eq, desc, sql } from "drizzle-orm";
import crypto from "crypto";

// Performance optimization: In-memory cache for recent openings
let recentOpeningsCache: { data: any[]; timestamp: number } | null = null;
const CACHE_DURATION = 30000; // 30 seconds cache

// Extend Express types for admin authentication
declare global {
  namespace Express {
    interface Request {
      adminUser?: any;
    }
    interface Session {
      adminToken?: string;
    }
  }
}

// Simple logout state for demo mode - using user balance as logout indicator
// If balance is exactly -1, user is logged out

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Also add the original widget endpoint for backward compatibility
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystery Boxes Widget</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'rarity-common': '#6B7280',
              'rarity-rare': '#10B981', 
              'rarity-epic': '#8B5CF6',
              'rarity-legendary': '#F59E0B',
              'rarity-mythical': '#EF4444',
              'primary': '#4F86F7',
              'card-foreground': '#F8FAFC'
            },
            backgroundImage: {
              'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
            }
          }
        }
      }
    </script>
    <style>
        :root {
            --primary: 79 134 247;
            --primary-foreground: 248 250 252;
            --accent: 139 92 246;
            --background: 15 23 42;
            --card: 30 41 59;
            --card-foreground: 248 250 252;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
            color: #F8FAFC;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        /* Navigation */
        .nav-tabs {
            display: flex;
            gap: 0.5rem;
            background: rgba(30, 41, 59, 0.5);
            padding: 0.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .nav-tab {
            flex: 1;
            background: transparent;
            color: #94A3B8;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .nav-tab.active {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            box-shadow: 0 4px 12px rgba(79, 134, 247, 0.3);
        }
        
        .nav-tab:hover:not(.active) {
            background: rgba(79, 134, 247, 0.1);
            color: hsl(var(--primary-foreground));
        }
        
        /* Content Sections */
        .content-section {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .content-section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .section-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .section-header h2 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, hsl(var(--primary)) 0%, hsl(var(--accent)) 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        .section-header p {
            color: #94A3B8;
            font-size: 1rem;
        }
        
        /* Grid Layouts */
        .mystery-box-grid, .battle-grid, .leaderboard-grid, .promo-grid, .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }
        
        /* Mystery Box Cards */
        .mystery-box {
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 1rem;
            padding: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .mystery-box:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border-color: rgba(79, 134, 247, 0.3);
        }
        
        .mystery-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(79, 134, 247, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .mystery-box:hover::before {
            opacity: 1;
        }
        
        .box-content {
            position: relative;
            z-index: 1;
        }
        
        .box-name {
            font-size: 1.125rem;
            font-weight: 600;
            color: hsl(var(--card-foreground));
            margin-bottom: 0.5rem;
        }
        
        .box-price {
            font-size: 1.25rem;
            font-weight: 700;
            color: hsl(var(--primary));
            margin-bottom: 1rem;
        }
        
        .open-button {
            width: 100%;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, hsl(var(--primary)) 0%, hsl(var(--accent)) 100%);
            color: hsl(var(--primary-foreground));
            border: none;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .open-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 134, 247, 0.3);
        }
        
        .rarity-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.25rem 0.5rem;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .rarity-badge.legendary {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
            color: white;
            animation: pulse 2s infinite;
        }
        

        
        /* Image containers matching whitelabel CaseCard exactly */
        .box-image, .item-image, .battle-image, .promotion-image {
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%);
        }
        
        .box-image img, .item-image img, .battle-image img, .promotion-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .battle-btn-primary {
            flex: 1;
            padding: 8px 12px;
            background: #4a5568;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .battle-btn-primary:hover {
            background: #718096;
        }

        .battle-btn-secondary {
            flex: 1;
            padding: 8px 12px;
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .battle-btn-secondary:hover {
            background: #4a5568;
        }

        .battle-btn-joined {
            flex: 1;
            padding: 8px 12px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .battle-btn-joined:hover {
            background: #8b5cf6;
        }

        .battle-btn-watch {
            flex: 1;
            padding: 8px 12px;
            background: #1f2937;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .battle-btn-watch:hover {
            background: #374151;
        }

        .battle-status {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            backdrop-filter: blur(8px);
        }

        .battle-status.waiting {
            background: rgba(245, 158, 11, 0.9);
            color: white;
        }

        .battle-status.active {
            background: rgba(34, 197, 94, 0.9);
            color: white;
        }

        .battle-status.finished {
            background: rgba(107, 114, 128, 0.9);
            color: white;
        }

        .battle-value {
            font-size: 14px;
            font-weight: 600;
            color: #10b981;
            margin: 4px 0;
        }

        .battle-participants {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 8px;
        }

        .battle-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .battle-item {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            padding: 12px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .battle-item:hover {
            transform: translateY(-2px);
            border-color: rgba(79, 134, 247, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .item-content {
            position: relative;
            z-index: 1;
        }

        .item-name {
            font-size: 14px;
            font-weight: 600;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .item-description {
            font-size: 11px;
            color: #94a3b8;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .item-price {
            font-size: 13px;
            font-weight: 600;
            color: #10b981;
        }

        .action-button {
            width: 100%;
            padding: 6px 12px;
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .action-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        .promotion-item {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .promotion-item:hover {
            transform: translateY(-2px);
            border-color: rgba(79, 134, 247, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .promo-content {
            position: relative;
            z-index: 1;
        }

        .promo-title {
            font-size: 16px;
            font-weight: 600;
            color: #f8fafc;
            margin-bottom: 8px;
        }

        .promo-description {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .promo-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .promo-progress, .promo-reward {
            font-size: 11px;
            color: #10b981;
        }

        .progress-btn {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .progress-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .achievement-item {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .achievement-item:hover {
            transform: translateY(-2px);
            border-color: rgba(79, 134, 247, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .achievement-item.unlocked {
            border-color: rgba(16, 185, 129, 0.3);
            background: rgba(16, 185, 129, 0.05);
        }

        .achievement-item.locked {
            opacity: 0.7;
        }

        .achievement-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .achievement-info h4 {
            font-size: 14px;
            font-weight: 600;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .achievement-info p {
            font-size: 11px;
            color: #94a3b8;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .achievement-progress, .achievement-reward {
            font-size: 10px;
            color: #10b981;
            margin-bottom: 2px;
        }

        .achievement-status {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 4px;
        }

        .achievement-status.unlocked {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .achievement-status.locked {
            background: rgba(107, 114, 128, 0.2);
            color: #94a3b8;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 0.5rem;
            }
            
            .nav-tabs {
                flex-wrap: wrap;
                gap: 0.25rem;
            }
            
            .nav-tab {
                font-size: 0.75rem;
                padding: 0.5rem 0.75rem;
            }
            
            .section-header h2 {
                font-size: 1.5rem;
            }
            
            .mystery-box-grid, .battle-grid, .leaderboard-grid, .promo-grid, .achievements-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        /* Result Popup */
        .result-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .result-content {
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            backdrop-filter: blur(20px);
            max-width: 400px;
            width: 90%;
        }

        .result-content h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 1rem;
        }

        .result-item {
            font-size: 1.125rem;
            font-weight: 600;
            color: #10b981;
            margin-bottom: 1rem;
        }

        .close-button {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Pulse animation for legendary items */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Rarity-specific styles */
        .rarity-glow-common { box-shadow: 0 0 20px rgba(107, 114, 128, 0.3); }
        .rarity-glow-rare { box-shadow: 0 0 20px rgba(16, 185, 129, 0.3); }
        .rarity-glow-epic { box-shadow: 0 0 20px rgba(139, 92, 246, 0.3); }
        .rarity-glow-legendary { box-shadow: 0 0 20px rgba(245, 158, 11, 0.3); }
        .rarity-glow-mythical { box-shadow: 0 0 20px rgba(239, 68, 68, 0.3); }
        
        /* Rank badges for leaderboards */
        .rank-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 24px;
            height: 24px;
            background: #374151;
            color: white;
            font-size: 11px;
            font-weight: 600;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .rank-badge.silver {
            background: linear-gradient(135deg, #E5E7EB 0%, #9CA3AF 100%);
            color: #1F2937;
        }
        
        .rank-badge.bronze {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
            color: white;
        }
        
        .your-rank {
            background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%);
            color: white;
        }
        
        .rank-2, .rank-3 {
            position: relative;
        }
        
        .leaderboard-item.you {
            border: 2px solid #4F46E5;
            background: rgba(79, 70, 229, 0.05);
        }
        
        /* Tab button styles for leaderboards */
        .tab-button {
            padding: 8px 16px;
            background: #374151;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .tab-button.active {
            background: #10b981;
        }
        
        .tab-button:hover:not(.active) {
            background: #4b5563;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <div class="nav-tabs">
            <button class="nav-tab active" data-section="boxes">
                üì¶ Mystery Boxes
            </button>
            <button class="nav-tab" data-section="inventory">
                üéí Inventory
            </button>
            <button class="nav-tab" data-section="battles">
                ‚öîÔ∏è Battles
            </button>
            <button class="nav-tab" data-section="leaderboards">
                üèÜ Leaderboards
            </button>
            <button class="nav-tab" data-section="promotions">
                üéÅ Promotions
            </button>
            <button class="nav-tab" data-section="achievements">
                üèÖ Achievements
            </button>
        </div>

        <!-- Mystery Boxes Section -->
        <div id="boxesSection" class="content-section active">
            <div class="section-header">
                <h2>üéÅ Mystery Boxes</h2>
                <p>Discover amazing prizes in our premium mystery boxes</p>
            </div>
            <div id="boxGrid" class="mystery-box-grid">
                <div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">Loading mystery boxes...</div>
            </div>
        </div>

        <!-- Inventory Section -->
        <div id="inventorySection" class="content-section">
            <div class="section-header">
                <h2>üéí Your Inventory</h2>
                <p>View and manage your collected items</p>
            </div>
            <div id="inventoryGrid" class="mystery-box-grid">
                <div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">Loading inventory...</div>
            </div>
        </div>

        <!-- Battles Section -->
        <div id="battlesSection" class="content-section">
            <div class="section-header">
                <h2>‚öîÔ∏è Case Battles</h2>
                <p>Join epic battles and compete for rare items</p>
            </div>
            <div id="battleGrid" class="battle-grid">
                <div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">Loading battles...</div>
            </div>
        </div>

        <!-- Leaderboards Section -->
        <div id="leaderboardsSection" class="content-section">
            <div class="section-header">
                <h2>üèÜ Leaderboards</h2>
                <p>See how you rank against other players</p>
            </div>
            <!-- Leaderboard Tabs -->
            <div class="leaderboard-tabs" style="display: flex; gap: 8px; margin-bottom: 24px; justify-content: center;">
                <button class="tab-button active" data-tab="spending" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-weight: 600;">Total Spent</button>
                <button class="tab-button" data-tab="cases" style="padding: 8px 16px; background: #374151; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">Cases Opened</button>
                <button class="tab-button" data-tab="rare_items" style="padding: 8px 16px; background: #374151; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">Rare Items</button>
            </div>
            
            <div class="leaderboard-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px;">
                <div style="text-align: center; padding: 40px; color: #888; grid-column: 1/-1;">Loading leaderboards...</div>
            </div>
        </div>

        <!-- Promotions Section -->
        <div id="promotionsSection" class="content-section">
            <div class="section-header">
                <h2>üéÅ Promotions</h2>
                <p>Claim your daily rewards and special offers</p>
            </div>
            <div class="promo-grid">
                <div class="promotion-item">
                    <div class="promo-content">
                        <div class="promo-title">
                            üéØ Daily Login Streak
                        </div>
                        <div class="promo-description">
                            Login daily for 7 days to unlock exclusive rewards
                        </div>
                        <div class="promo-details">
                            <div class="promo-progress">Progress: 4/7 days</div>
                            <div class="promo-reward">Reward: Epic Box</div>
                        </div>
                        <button class="progress-btn">Continue</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Achievements Section -->
        <div id="achievementsSection" class="content-section">
            <div class="section-header">
                <h2>üèÖ Achievements</h2>
                <p>Unlock rewards for your accomplishments</p>
            </div>
            <div class="achievements-grid">
                <div class="achievement-item unlocked">
                    <div class="achievement-icon">üéÅ</div>
                    <div class="achievement-info">
                        <h4>First Box</h4>
                        <p>Open your first mystery box</p>
                        <div class="achievement-progress">Progress: 1/1</div>
                        <div class="achievement-reward">Reward: Bonus Coins</div>
                        <div class="achievement-status unlocked">UNLOCKED</div>
                    </div>
                </div>
                <div class="achievement-item locked">
                    <div class="achievement-icon">‚ö°</div>
                    <div class="achievement-info">
                        <h4>Speed Demon</h4>
                        <p>Open 50 boxes in one day</p>
                        <div class="achievement-progress">Progress: 0/50</div>
                        <div class="achievement-reward">Reward: Lightning Effect</div>
                        <div class="achievement-status locked">LOCKED</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="resultPopup" class="result-popup">
        <div class="result-content">
            <h3>Box Opened!</h3>
            <div id="resultItem" class="result-item">Loading...</div>
            <div id="resultRarity"></div>
            <button class="close-button" onclick="closePopup()">Continue</button>
        </div>
    </div>
    
    <script>
        // Extract partner from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const partnerParam = urlParams.get('partner') || 'test';
        
        // Map partner names to API keys
        const partnerApiKeys = {
            'test': 'test',
            'rolling-riches': 'rolling-riches',
            'default': 'test'
        };
        
        const apiConfig = {
            endpoint: window.location.origin,
            apiKey: partnerApiKeys[partnerParam] || partnerApiKeys['default'],
            partner: partnerParam
        };
        
        console.log('Partner config:', { partnerParam, apiKey: apiConfig.apiKey });
        
        // API Request Function with Partner Authentication
        async function apiRequest(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                'X-API-Key': apiConfig.apiKey,
                ...options.headers
            };
            
            console.log('Making API request:', url, 'with headers:', headers);
            
            const response = await fetch(apiConfig.endpoint + url, {
                ...options,
                headers
            });
            
            if (!response.ok) {
                throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
            }
            
            return response.json();
        }
        
        // Get full image URL
        function getFullImageUrl(imageUrl) {
            if (!imageUrl) return 'https://images.unsplash.com/photo-1553062407-98eeb64c6a62?w=400';
            if (imageUrl.startsWith('http')) return imageUrl;
            
            const fullUrl = apiConfig.endpoint + imageUrl;
            console.log('Converting image URL:', imageUrl, 'to:', fullUrl);
            return fullUrl;
        }
        
        // Navigation functionality
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and sections
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
                
                // Add active class to clicked tab
                tab.classList.add('active');
                
                // Show corresponding section
                const sectionName = tab.dataset.section;
                const section = document.getElementById(sectionName + 'Section');
                if (section) {
                    section.classList.add('active');
                    
                    // Load content based on section
                    if (sectionName === 'inventory') {
                        loadInventory();
                    } else if (sectionName === 'battles') {
                        loadBattles();
                    } else if (sectionName === 'leaderboards') {
                        loadLeaderboards('spending');
                    }
                }
            });
        });
        
        async function loadInventory() {
            const gridEl = document.getElementById('inventoryGrid');
            
            try {
                console.log('Loading inventory...');
                const result = await apiRequest('/api/partner/v1/inventory?externalUserId=' + apiConfig.partner + '_demo_user');
                console.log('Inventory loaded:', result);
                
                if (result && result.inventory && Array.isArray(result.inventory)) {
                    displayInventory(result.inventory);
                } else {
                    gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">No items in inventory</div>';
                }
            } catch (error) {
                console.error('Failed to load inventory:', error);
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Failed to load inventory: ' + error.message + '</div>';
            }
        }
        
        function displayInventory(inventory) {
            const gridEl = document.getElementById('inventoryGrid');
            
            if (!inventory.length) {
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">Your inventory is empty</div>';
                return;
            }
            
            gridEl.innerHTML = inventory.map(item => {
                const rarityMap = {
                    'common': { bg: 'bg-gray-600', text: 'text-gray-100', border: 'border-gray-500' },
                    'rare': { bg: 'bg-green-600', text: 'text-green-100', border: 'border-green-500' },
                    'epic': { bg: 'bg-purple-600', text: 'text-purple-100', border: 'border-purple-500' },
                    'legendary': { bg: 'bg-orange-600', text: 'text-orange-100', border: 'border-orange-500' },
                    'mythical': { bg: 'bg-red-600', text: 'text-red-100', border: 'border-red-500' }
                };
                const rarity = rarityMap[item.rarity] || rarityMap['common'];
                
                return '<div class="battle-item">' +
                    '<div class="item-image">' +
                        '<img src="' + getFullImageUrl(item.icon) + '" alt="' + item.name + '" />' +
                        '<div class="rarity-badge ' + item.rarity + '">' + item.rarity.toUpperCase() + '</div>' +
                    '</div>' +
                    '<div class="item-content">' +
                        '<div class="item-name">' + item.name + '</div>' +
                        '<div class="item-description">' + (item.description || 'Rare item from ' + item.boxName) + '</div>' +
                        '<div class="item-price">Qty: ' + (item.quantity || 1) + ' | Value: $' + (item.value || '0.00') + '</div>' +
                        '<button class="action-button">View Details</button>' +
                    '</div>' +
                '</div>';
            }).join('');
        }
        
        async function loadBattles() {
            const gridEl = document.getElementById('battleGrid');
            
            try {
                console.log('Loading battles...');
                const result = await apiRequest('/api/partner/v1/battles');
                console.log('Battles loaded:', result);
                
                if (result && result.battles && Array.isArray(result.battles)) {
                    displayBattles(result.battles);
                } else if (result && Array.isArray(result)) {
                    displayBattles(result);
                } else {
                    gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">No active battles</div>';
                }
            } catch (error) {
                console.error('Failed to load battles:', error);
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Failed to load battles: ' + error.message + '</div>';
            }
        }
        
        function displayBattles(battles) {
            const gridEl = document.getElementById('battleGrid');
            
            if (!battles.length) {
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">No battles available</div>';
                return;
            }
            
            gridEl.innerHTML = battles.map(battle => {
                const statusClass = battle.status === 'waiting' ? 'waiting' : 
                                  battle.status === 'active' ? 'active' : 'finished';
                const actionButton = battle.status === 'waiting' ? 
                    '<button class="battle-btn-primary">Join Battle</button>' :
                    battle.status === 'active' ? 
                    '<button class="battle-btn-joined">Joined</button>' :
                    '<button class="battle-btn-watch">View Results</button>';
                
                return '<div class="battle-item">' +
                    '<div class="battle-image">' +
                        '<img src="' + getFullImageUrl(battle.imageUrl) + '" alt="' + battle.name + '" />' +
                        '<div class="battle-status ' + statusClass + '">' + battle.status.toUpperCase() + '</div>' +
                    '</div>' +
                    '<div class="item-content">' +
                        '<div class="item-name">' + battle.name + '</div>' +
                        '<div class="battle-value">Prize Pool: $' + (battle.prizePool || battle.totalValue || '0.00') + '</div>' +
                        '<div class="battle-participants">' + (battle.currentPlayers || 0) + '/' + (battle.maxPlayers || 4) + ' players</div>' +
                        '<div class="battle-actions">' +
                            actionButton +
                        '</div>' +
                    '</div>' +
                '</div>';
            }).join('');
        }

        async function loadStatistics() {
            // Placeholder for statistics loading
            console.log('Loading statistics...');
        }

        async function loadLeaderboards(type = 'spending') {
            console.log('Loading leaderboards for type:', type);
            const leaderboardGrid = document.querySelector('.leaderboard-grid');
            
            if (!leaderboardGrid) {
                console.error('Leaderboard grid not found');
                return;
            }
            
            try {
                // Use partner API endpoint based on type
                const endpoint = '/api/partner/v1/leaderboard/' + type;
                console.log('Making API request to:', endpoint);
                
                const result = await apiRequest(endpoint);
                console.log('Leaderboard API response:', result);
                
                if (result && result.leaderboard && Array.isArray(result.leaderboard)) {
                    displayLeaderboard(result.leaderboard, type);
                } else if (result && Array.isArray(result)) {
                    displayLeaderboard(result, type);
                } else {
                    console.log('No leaderboard data found');
                    leaderboardGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: #888; grid-column: 1/-1;">No leaderboard data available</div>';
                }
            } catch (error) {
                console.error('Failed to load leaderboards:', error);
                // Show static data matching whitelabel format as fallback
                displayStaticLeaderboard(type);
            }
        }

        function displayLeaderboard(leaderboard, type) {
            const leaderboardGrid = document.querySelector('.leaderboard-grid');
            
            if (!leaderboard.length) {
                leaderboardGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: #888; grid-column: 1/-1;">No players yet</div>';
                return;
            }
            
            const formatValue = (value, entryType) => {
                if (entryType === 'spending') return '$' + (value || '0');
                if (entryType === 'cases') return (value || '0') + ' cases';
                if (entryType === 'rare_items') return (value || '0') + ' rare items';
                return value || '0';
            };
            
            leaderboardGrid.innerHTML = leaderboard.slice(0, 6).map((player, index) => {
                const rank = index + 1;
                const rankBadgeClass = rank === 1 ? 'legendary' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                
                return '<div class="mystery-box">' +
                    '<div class="box-image">' +
                        '<img src="' + (player.avatar || 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=300&h=300&fit=crop&crop=face') + '" alt="' + (player.username || 'Player') + '" />' +
                        '<div class="rarity-badge ' + rankBadgeClass + '">#' + rank + '</div>' +
                    '</div>' +
                    '<div class="box-content">' +
                        '<div class="box-name">' + (player.username || 'Player ' + rank) + '</div>' +
                        '<div class="box-price">' + formatValue(player.value || player.totalSpent || player.casesOpened || player.rareItems, type) + '</div>' +
                        '<button class="open-button">View Profile</button>' +
                    '</div>' +
                '</div>';
            }).join('');
        }

        function displayStaticLeaderboard(type) {
            const leaderboardGrid = document.querySelector('.leaderboard-grid');
            
            // Static data matching whitelabel format
            const staticData = [
                { username: 'CryptoKing', value: '$15,420', avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=300&h=300&fit=crop&crop=face' },
                { username: 'LuckyStrike', value: '$12,890', avatar: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=100&h=100&fit=crop&crop=face' },
                { username: 'BoxMaster', value: '$9,750', avatar: 'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=100&h=100&fit=crop&crop=face' }
            ];
            
            leaderboardGrid.innerHTML = staticData.map((player, index) => {
                const rank = index + 1;
                const rankBadgeClass = rank === 1 ? 'legendary' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                
                return '<div class="mystery-box">' +
                    '<div class="box-image">' +
                        '<img src="' + player.avatar + '" alt="' + player.username + '" />' +
                        '<div class="rarity-badge ' + rankBadgeClass + '">#' + rank + '</div>' +
                    '</div>' +
                    '<div class="box-content">' +
                        '<div class="box-name">' + player.username + '</div>' +
                        '<div class="box-price">' + player.value + '</div>' +
                        '<button class="open-button">View Profile</button>' +
                    '</div>' +
                '</div>';
            }).join('');
        }

        // Tab switching functionality
        function setupLeaderboardTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all tabs
                    tabButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#374151';
                    });
                    
                    // Add active class to clicked tab
                    button.classList.add('active');
                    button.style.background = button.dataset.tab === 'spending' ? '#10b981' : 
                                            button.dataset.tab === 'cases' ? '#3b82f6' : '#8b5cf6';
                    
                    // Load leaderboard for selected type
                    loadLeaderboards(button.dataset.tab);
                });
            });
        }
        
        async function loadBoxes() {
            const gridEl = document.getElementById('boxGrid');
            
            try {
                console.log('Starting to load boxes...');
                const result = await apiRequest('/api/partner/v1/boxes');
                console.log('Boxes loaded successfully:', result);
                
                if (result && result.boxes && Array.isArray(result.boxes)) {
                    displayBoxes(result.boxes);
                } else if (result && Array.isArray(result)) {
                    displayBoxes(result);
                } else {
                    console.error('Invalid response format:', result);
                    gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Invalid data format received</div>';
                }
            } catch (error) {
                console.error('Failed to load boxes:', error);
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Failed to load mystery boxes: ' + error.message + '</div>';
            }
        }
        
        function displayBoxes(boxes) {
            const gridEl = document.getElementById('boxGrid');
            
            if (!boxes.length) {
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">No mystery boxes available</div>';
                return;
            }
            
            // Show featured boxes first, then others, limit to 12 for iframe
            const featuredBoxes = boxes.filter(function(box) { return box.featured; }).slice(0, 6);
            const otherBoxes = boxes.filter(function(box) { return !box.featured; }).slice(0, 6);
            const displayBoxes = featuredBoxes.concat(otherBoxes).slice(0, 12);
            
            gridEl.innerHTML = displayBoxes.map(function(box) {
                const imageUrl = getFullImageUrl(box.imageUrl);
                // Map rarity to actual CSS classes
                const rarityMap = {
                    'common': { bg: 'bg-gray-600', text: 'text-gray-100', border: 'border-gray-500' },
                    'rare': { bg: 'bg-green-600', text: 'text-green-100', border: 'border-green-500' },
                    'epic': { bg: 'bg-purple-600', text: 'text-purple-100', border: 'border-purple-500' },
                    'legendary': { bg: 'bg-orange-600', text: 'text-orange-100', border: 'border-orange-500' },
                    'mythical': { bg: 'bg-red-600', text: 'text-red-100', border: 'border-red-500' }
                };
                const rarity = rarityMap[box.rarity] || rarityMap['common'];
                const rarityBorder = rarity.border;
                const rarityBg = rarity.bg;
                const rarityText = rarity.text;
                const rarityGlow = 'rarity-glow-' + box.rarity;
                console.log('Box:', box.name, 'Image URL:', imageUrl);
                
                return '<div class="mystery-box group cursor-pointer" data-rarity="' + box.rarity + '" onclick="openBox(' + box.id + ')">' +
                    '<div class="relative overflow-hidden rounded-xl glass-effect border card-hover ' + rarityBorder + ' ' + rarityGlow + '">' +
                        '<div class="absolute top-0 left-0 right-0 h-1 ' + rarityBg + '"></div>' +
                        '<div class="absolute inset-0 animate-shimmer opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>' +
                        '<div class="aspect-square overflow-hidden relative">' +
                            '<img src="' + imageUrl + '" alt="' + box.name + '" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" />' +
                            '<div class="absolute inset-0 bg-gradient-to-t from-black/60 via-black/20 to-transparent"></div>' +
                            '<div class="absolute top-2 right-2 flex flex-col gap-2 items-end">' +
                                '<div class="' + rarityBg + ' ' + rarityText + ' backdrop-blur-sm font-bold px-2 py-1 rounded text-xs border border-white/20">' +
                                    box.rarity.toUpperCase() +
                                '</div>' +
                                '<button class="w-8 h-8 p-0 rounded-full backdrop-blur-sm bg-black/50 hover:bg-red-500/90 text-white/70 hover:text-white transition-all duration-300 flex items-center justify-center">' +
                                    '<svg class="w-4 h-4 hover:scale-110 transition-all duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>' +
                                '</button>' +
                            '</div>' +
                        '</div>' +
                        '<div class="p-2 relative z-10">' +
                            '<div class="flex items-center justify-between mb-1">' +
                                '<h3 class="text-sm font-bold text-card-foreground group-hover:text-primary transition-colors truncate flex-1 mr-2">' +
                                    box.name +
                                '</h3>' +
                            '</div>' +
                            '<div class="flex items-center justify-between mt-2">' +
                                '<div class="text-sm font-bold text-primary">$' + box.price + '</div>' +
                                '<div class="flex gap-1">' +
                                    '<button class="text-primary border-primary/30 hover:bg-primary/10 p-1 w-6 h-6 rounded border flex items-center justify-center">' +
                                        '<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>' +
                                    '</button>' +
                                    '<button class="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-semibold px-2 py-1 text-xs rounded flex items-center transition-all duration-300" onclick="event.stopPropagation(); openBox(' + box.id + ')">' +
                                        '<svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>' +
                                        'Open' +
                                    '</button>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="absolute inset-0 rounded-xl opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none" style="box-shadow: 0 0 30px ' + 
                            (box.rarity === 'common' ? 'rgba(148, 163, 184, 0.5)' :
                             box.rarity === 'rare' ? 'rgba(22, 163, 74, 0.5)' :
                             box.rarity === 'epic' ? 'rgba(139, 92, 246, 0.5)' :
                             box.rarity === 'legendary' ? 'rgba(245, 158, 11, 0.5)' :
                             'rgba(239, 68, 68, 0.5)') + 
                        '"></div>' +
                    '</div>' +
                '</div>';
            }).join('');
        }
        
        async function openBox(boxId) {
            const popup = document.getElementById('resultPopup');
            const resultItem = document.getElementById('resultItem');
            const resultRarity = document.getElementById('resultRarity');
            
            popup.style.display = 'flex';
            resultItem.innerHTML = '<div class="loading"></div> Opening box...';
            resultRarity.textContent = '';
            
            try {
                const result = await apiRequest('/api/partner/v1/boxes/' + boxId + '/open', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        externalUserId: '${partner || 'b2b'}_user_' + Date.now(),
                        amount: 1
                    })
                });
                
                if (result.success && result.data && result.data.item) {
                    const item = result.data.item;
                    resultItem.textContent = item.name;
                    resultRarity.innerHTML = '<div class="box-rarity rarity-' + item.rarity + '" style="position: static; margin: 10px auto; display: inline-block;">' +
                        item.rarity +
                        '</div>' +
                        '<div style="margin-top: 10px; color: #0079F2;">' +
                        'Value: $' + item.value + ' | Profit: $' + result.data.transaction.profit +
                        '</div>';
                } else {
                    resultItem.textContent = 'Error opening box';
                    resultRarity.textContent = result.message || 'Unknown error';
                }
            } catch (error) {
                console.error('Failed to open box:', error);
                resultItem.textContent = 'Failed to open box';
                resultRarity.textContent = error.message;
            }
        }
        
        function closePopup() {
            document.getElementById('resultPopup').style.display = 'none';
        }
        
        // Auto-load content when page loads
        window.addEventListener('load', function() {
            loadBoxes();
            setupLeaderboardTabs();
            loadLeaderboards('spending'); // Load default leaderboard
        });
    </script>
</body>
</html>`;

    // Force override all security headers after processing
    res.removeHeader('X-Frame-Options');
    res.removeHeader('Content-Security-Policy');
    res.removeHeader('X-Content-Type-Options');
    res.setHeader('X-Frame-Options', 'ALLOWALL');
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    
    res.send(iframeHTML);
  });

  // Also add the original widget endpoint for backward compatibility  
  app.get('/widget/iframe', async (req, res) => {
    // Disable all security middleware for iframe embedding
    res.set({
      'X-Frame-Options': 'ALLOWALL',
      'Content-Security-Policy': '',
      'X-Content-Security-Policy': '',
      'X-WebKit-CSP': '',
    });
    
    // Remove any existing security headers
    res.removeHeader('Content-Security-Policy');
    res.removeHeader('X-Content-Security-Policy');
    res.removeHeader('X-WebKit-CSP');
    res.removeHeader('X-Frame-Options');
    res.removeHeader('X-Content-Type-Options');
    res.removeHeader('X-XSS-Protection');
    res.removeHeader('Referrer-Policy');
    res.removeHeader('Permissions-Policy');
    
    const { partner } = req.query;
    
    const iframeHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystery Boxes Widget</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'rarity-common': '#6B7280',
              'rarity-rare': '#10B981', 
              'rarity-epic': '#8B5CF6',
              'rarity-legendary': '#F59E0B',
              'rarity-mythical': '#EF4444',
              'primary': '#4F86F7',
              'card-foreground': '#F8FAFC'
            },
            backgroundImage: {
              'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
            }
          }
        }
      }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --background: 220 100% 4%;
            --foreground: 210 40% 98%;
            --muted: 240 38% 15%;
            --muted-foreground: 215 20% 65%;
            --popover: 235 100% 8%;
            --popover-foreground: 210 40% 98%;
            --card: 225 39% 11%;
            --card-foreground: 210 40% 98%;
            --border: 240 30% 18%;
            --input: 240 30% 18%;
            --primary: 217 91% 65%;
            --primary-foreground: 210 40% 98%;
            --secondary: 240 38% 20%;
            --secondary-foreground: 210 40% 98%;
            --accent: 280 100% 70%;
            --accent-foreground: 210 40% 98%;
            --destructive: 0 84% 60%;
            --destructive-foreground: 210 40% 98%;
            --ring: 217 91% 65%;
            --radius: 0.75rem;
            --rarity-common: 215 20% 70%;
            --rarity-rare: 142 76% 45%;
            --rarity-epic: 256 71% 70%;
            --rarity-legendary: 32 95% 55%;
            --rarity-mythical: 0 84% 65%;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #000A1A 0%, #1A1B3A 25%, #252647 50%, #1A1B3A 75%, #000A1A 100%);
            background-size: 400% 400%;
            background-attachment: fixed;
            animation: gradientShift 20s ease infinite;
            color: #f8fafc;
            overflow-x: hidden;
            padding: 1rem;
            margin: 0;
            min-height: 100vh;
        }
        
        /* Full-screen mode styles */
        body.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            z-index: 9999;
        }
        
        .app-container.fullscreen {
            padding: 0;
            height: 100vh;
            overflow-y: auto;
        }
        
        .navbar.fullscreen {
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
            background: rgba(0, 10, 26, 0.95);
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .animate-shimmer {
            background: linear-gradient(110deg, transparent 8%, rgba(255, 255, 255, 0.1) 18%, transparent 33%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        
        .animate-float {
            animation: float 3s ease-in-out infinite;
        }
        
        .button-gradient {
            background: linear-gradient(135deg, #4F86F7 0%, #CC33FF 50%, #F59E0B 100%);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(79, 134, 247, 0.4);
            transition: all 0.3s ease;
        }
        
        .button-gradient:hover {
            background: linear-gradient(135deg, #3B73E7 0%, #B829E6 50%, #E68A00 100%);
            box-shadow: 0 8px 30px rgba(79, 134, 247, 0.6);
            transform: translateY(-2px);
        }
        
        /* Glow shadow effects for each rarity */
        .glow-shadow-common {
            box-shadow: 0 0 30px rgba(148, 163, 184, 0.5);
        }
        
        .glow-shadow-rare {
            box-shadow: 0 0 30px rgba(22, 163, 74, 0.5);
        }
        
        .glow-shadow-epic {
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
        }
        
        .glow-shadow-legendary {
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.5);
        }
        
        .glow-shadow-mythical {
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        }
        
        /* Utility classes */
        .aspect-square {
            aspect-ratio: 1 / 1;
        }
        
        .text-primary {
            color: #4F86F7;
        }
        
        .group:hover .group-hover\\:opacity-100 {
            opacity: 1;
        }
        
        .group:hover .group-hover\\:scale-110 {
            transform: scale(1.1);
        }
        
        .group:hover .group-hover\\:text-primary {
            color: #4F86F7;
        }
        
        .transition-opacity {
            transition-property: opacity;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        
        .transition-transform {
            transition-property: transform;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        
        .transition-colors {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        
        .duration-300 {
            transition-duration: 300ms;
        }
        
        .duration-500 {
            transition-duration: 500ms;
        }
        
        .widget-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .header h1 {
            font-size: 28px;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 8px;
        }
        
        .header p {
            color: #94a3b8;
            font-size: 14px;
        }
        
        /* Navigation menu with glass effect */
        .nav-menu {
            background: rgba(21, 23, 41, 0.6);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .nav-items {
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .nav-item {
            padding: 8px 16px;
            border-radius: 6px;
            background: transparent;
            color: #94a3b8;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
        }
        
        .nav-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #f8fafc;
        }
        
        .nav-item.active {
            background: rgba(79, 134, 247, 0.1);
            color: #4f86f7;
        }
        
        /* Content sections */
        .content-section {
            display: none;
        }
        
        .content-section.active {
            display: block;
        }
        
        .section-header {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .section-header h2 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #4F86F7, #CC33FF);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        
        .section-header p {
            color: #ccc;
            font-size: 0.9em;
        }
        
        /* Stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(21, 23, 41, 0.6);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }
        
        .stat-card h3 {
            color: #ccc;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .stat-value {
            color: #FF6B35;
            font-size: 2em;
            font-weight: bold;
        }
        
        /* Placeholder messages */
        .placeholder-message {
            text-align: center;
            padding: 60px 20px;
            color: #888;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }
        
        .inventory-grid, .market-grid, .battles-grid, .promotions-grid, 
        .leaderboard-grid, .achievements-grid {
            margin-top: 20px;
        }
        
        /* CSS Variables matching whitelabel exactly */
        :root {
            --background: 220 100% 4%;
            --foreground: 210 40% 98%;
            --muted: 240 38% 15%;
            --muted-foreground: 215 20% 65%;
            --popover: 235 100% 8%;
            --popover-foreground: 210 40% 98%;
            --card: 225 39% 11%;
            --card-foreground: 210 40% 98%;
            --border: 240 30% 18%;
            --input: 240 30% 18%;
            --primary: 217 91% 65%;
            --primary-foreground: 210 40% 98%;
            --secondary: 240 38% 20%;
            --secondary-foreground: 210 40% 98%;
            --accent: 280 100% 70%;
            --accent-foreground: 210 40% 98%;
            --destructive: 0 84% 60%;
            --destructive-foreground: 210 40% 98%;
            --ring: 217 91% 65%;
            --radius: 0.75rem;
            --rarity-common: 215 20% 70%;
            --rarity-rare: 142 76% 45%;
            --rarity-epic: 256 71% 70%;
            --rarity-legendary: 32 95% 55%;
            --rarity-mythical: 0 84% 65%;
        }
        
        /* Box grid */
        .box-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
            padding: 1.25rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* Widget grid */
        .widget-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
            padding: 1.25rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* Tailwind utility classes */
        .aspect-square { aspect-ratio: 1 / 1; }
        .overflow-hidden { overflow: hidden; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .object-cover { object-fit: cover; }
        .rounded-xl { border-radius: 0.75rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .text-white { color: rgb(255 255 255); }
        .text-xs { font-size: 0.75rem; line-height: 1rem; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-1 { gap: 0.25rem; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .flex-col { flex-direction: column; }
        .items-end { align-items: flex-end; }
        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .top-4 { top: 1rem; }
        .right-4 { right: 1rem; }
        .w-6 { width: 1.5rem; }
        .h-6 { height: 1.5rem; }
        .w-8 { width: 2rem; }
        .h-8 { height: 2rem; }
        .w-3 { width: 0.75rem; }
        .h-3 { height: 0.75rem; }
        .w-4 { width: 1rem; }
        .h-4 { height: 1rem; }
        .mr-1 { margin-right: 0.25rem; }
        .mr-2 { margin-right: 0.5rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .z-10 { z-index: 10; }
        .rounded-full { border-radius: 9999px; }
        .rounded { border-radius: 0.25rem; }
        .border { border-width: 1px; }
        .flex-1 { flex: 1 1 0%; }
        .min-w-0 { min-width: 0px; }
        .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .cursor-pointer { cursor: pointer; }
        .uppercase { text-transform: uppercase; }
        
        /* Glass effect exactly from whitelabel */
        .glass-effect {
            backdrop-filter: blur(16px);
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(148, 163, 184, 0.15);
        }
        
        /* Card hover exactly from whitelabel */
        .card-hover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .card-hover:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 0 40px rgba(59, 130, 246, 0.3);
        }
        
        /* Button gradient exactly from whitelabel */
        .button-gradient {
            background: linear-gradient(135deg, #4F86F7 0%, #CC33FF 50%, #F59E0B 100%);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(79, 134, 247, 0.4);
            transition: all 0.3s ease;
        }
        
        .button-gradient:hover {
            background: linear-gradient(135deg, #3B73E7 0%, #B829E6 50%, #E68A00 100%);
            box-shadow: 0 8px 30px rgba(79, 134, 247, 0.6);
            transform: translateY(-2px);
        }
        
        /* Rarity colors and backgrounds exactly from whitelabel */
        .bg-gray-600 { background-color: #6B7280; }
        .text-gray-100 { color: #F3F4F6; }
        .border-gray-500 { border-color: #6B7280; }
        
        .bg-green-600 { background-color: #10B981; }
        .text-green-100 { color: #D1FAE5; }
        .border-green-500 { border-color: #10B981; }
        
        .bg-purple-600 { background-color: #8B5CF6; }
        .text-purple-100 { color: #EDE9FE; }
        .border-purple-500 { border-color: #8B5CF6; }
        
        .bg-orange-600 { background-color: #F59E0B; }
        .text-orange-100 { color: #FEF3C7; }
        .border-orange-500 { border-color: #F59E0B; }
        
        .bg-red-600 { background-color: #EF4444; }
        .text-red-100 { color: #FEE2E2; }
        .border-red-500 { border-color: #EF4444; }
        
        /* Primary color */
        .text-primary { color: hsl(var(--primary)); }
        .border-primary\/30 { border-color: hsl(var(--primary) / 0.3); }
        .hover\\:bg-primary\/10:hover { background-color: hsl(var(--primary) / 0.1); }
        
        /* Card foreground */
        .text-card-foreground { color: hsl(var(--card-foreground)); }
        .group-hover\\:text-primary:hover { color: hsl(var(--primary)); }
        
        /* Transitions */
        .transition-colors { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .transition-transform { transition-property: transform; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .transition-opacity { transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .transition-all { transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .duration-300 { transition-duration: 300ms; }
        .duration-500 { transition-duration: 500ms; }
        
        /* Hover states */
        .group:hover .group-hover\\:scale-110 { transform: scale(1.1); }
        .group:hover .group-hover\\:opacity-100 { opacity: 1; }
        .group:hover .group-hover\\:text-primary { color: hsl(var(--primary)); }
        
        /* Background colors */
        .bg-black\/50 { background-color: rgb(0 0 0 / 0.5); }
        .hover\\:bg-black\/70:hover { background-color: rgb(0 0 0 / 0.7); }
        .text-white\/70 { color: rgb(255 255 255 / 0.7); }
        .hover\\:text-white:hover { color: rgb(255 255 255); }
        
        /* Backdrop blur */
        .backdrop-blur-sm { backdrop-filter: blur(4px); }
        
        /* Keyframe animations exactly from whitelabel */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Animations exactly from whitelabel */
        .animate-shimmer {
            background: linear-gradient(110deg, transparent 8%, rgba(255, 255, 255, 0.1) 18%, transparent 33%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        
        .animate-float {
            animation: float 3s ease-in-out infinite;
        }
        
        /* Rarity glow effects exactly from whitelabel */
        .rarity-glow-common {
            box-shadow: 0 0 20px rgba(148, 163, 184, 0.3);
        }
        
        .rarity-glow-rare {
            box-shadow: 0 0 20px rgba(22, 163, 74, 0.3);
        }
        
        .rarity-glow-epic {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }
        
        .rarity-glow-legendary {
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
        }
        
        .rarity-glow-mythical {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
        }
        
        .opacity-0 { opacity: 0; }
        .group-hover\\:opacity-100 { opacity: 0; }
        .group:hover .group-hover\\:opacity-100 { opacity: 1; }
        
        /* Exact grid classes matching whitelabel platform */
        .box-grid, .inventory-grid, .market-grid, .battles-grid, 
        .promotions-grid, .leaderboard-grid, .achievements-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 1rem;
            padding: 0;
        }
        
        @media (min-width: 768px) {
            .box-grid, .inventory-grid, .market-grid, .battles-grid, 
            .promotions-grid, .leaderboard-grid, .achievements-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }
        
        @media (min-width: 1024px) {
            .box-grid, .inventory-grid, .market-grid, .battles-grid, 
            .promotions-grid, .leaderboard-grid, .achievements-grid {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }
        }
        
        @media (min-width: 1280px) {
            .box-grid, .inventory-grid, .market-grid, .battles-grid, 
            .promotions-grid, .leaderboard-grid, .achievements-grid {
                grid-template-columns: repeat(5, minmax(0, 1fr));
            }
        }
        
        /* Rarity color definitions matching whitelabel */
        .rarity-common { color: hsl(158 64% 52%); }
        .bg-rarity-common { background-color: hsl(158 64% 52%); }
        .border-rarity-common { border-color: hsl(158 64% 52%); }
        
        .rarity-rare { color: hsl(217 91% 60%); }
        .bg-rarity-rare { background-color: hsl(217 91% 60%); }
        .border-rarity-rare { border-color: hsl(217 91% 60%); }
        
        .rarity-epic { color: hsl(256 71% 70%); }
        .bg-rarity-epic { background-color: hsl(256 71% 70%); }
        .border-rarity-epic { border-color: hsl(256 71% 70%); }
        
        .rarity-legendary { color: hsl(32 95% 55%); }
        .bg-rarity-legendary { background-color: hsl(32 95% 55%); }
        .border-rarity-legendary { border-color: hsl(32 95% 55%); }
        
        .rarity-mythical { color: hsl(0 84% 65%); }
        .bg-rarity-mythical { background-color: hsl(0 84% 65%); }
        .border-rarity-mythical { border-color: hsl(0 84% 65%); }
        
        /* Glass effect exactly matching whitelabel */
        .glass-effect {
            backdrop-filter: blur(16px);
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Card hover exactly matching whitelabel */
        .card-hover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .card-hover:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 0 40px rgba(59, 130, 246, 0.3);
        }
        
        .mystery-box, .inventory-item, .market-item, .battle-item, 
        .promotion-item, .leaderboard-item, .achievement-item {
            position: relative;
            overflow: hidden;
            border-radius: 0.75rem;
            cursor: pointer;
            backdrop-filter: blur(16px);
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Rarity-specific backgrounds for mystery boxes */
        .mystery-box[data-rarity="common"] {
            background: linear-gradient(135deg, hsl(var(--rarity-common) / 0.15) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-color: hsl(var(--rarity-common) / 0.3);
        }
        
        .mystery-box[data-rarity="uncommon"] {
            background: linear-gradient(135deg, hsl(var(--rarity-uncommon) / 0.15) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-color: hsl(var(--rarity-uncommon) / 0.3);
        }
        
        .mystery-box[data-rarity="rare"] {
            background: linear-gradient(135deg, hsl(var(--rarity-rare) / 0.15) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-color: hsl(var(--rarity-rare) / 0.3);
        }
        
        .mystery-box[data-rarity="epic"] {
            background: linear-gradient(135deg, hsl(var(--rarity-epic) / 0.15) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-color: hsl(var(--rarity-epic) / 0.3);
        }
        
        .mystery-box[data-rarity="legendary"] {
            background: linear-gradient(135deg, hsl(var(--rarity-legendary) / 0.15) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-color: hsl(var(--rarity-legendary) / 0.3);
        }
        
        .mystery-box[data-rarity="mythical"] {
            background: linear-gradient(135deg, hsl(var(--rarity-mythical) / 0.15) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-color: hsl(var(--rarity-mythical) / 0.3);
        }

        .mystery-box:hover, .inventory-item:hover, .market-item:hover, 
        .battle-item:hover, .promotion-item:hover, .leaderboard-item:hover, 
        .achievement-item:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 0 40px rgba(59, 130, 246, 0.3);
        }
        
        .box-image {
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            background: linear-gradient(135deg, rgba(79, 134, 247, 0.1) 0%, rgba(204, 51, 255, 0.1) 100%);
        }
        
        .box-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s ease;
        }
        
        .mystery-box:hover .box-image img {
            transform: scale(1.1);
        }
        
        .box-content {
            padding: 0.5rem;
            position: relative;
            z-index: 10;
        }
        
        .box-name {
            font-size: 0.875rem;
            font-weight: 700;
            color: hsl(var(--card-foreground));
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .box-price {
            font-size: 0.875rem;
            font-weight: 700;
            color: hsl(var(--primary));
            margin-bottom: 0.5rem;
        }
        
        .open-button {
            width: 100%;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, hsl(var(--primary)) 0%, hsl(var(--accent)) 100%);
            color: hsl(var(--primary-foreground));
            border: none;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .open-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 134, 247, 0.3);
        }
        
        .rarity-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.25rem 0.5rem;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .rarity-badge.legendary {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
            color: white;
            animation: pulse 2s infinite;
        }
        

        
        /* Image containers matching whitelabel CaseCard exactly */
        .box-image, .item-image, .battle-image, .promotion-image {
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.4) 100%);
        }
        
        .box-image img, .item-image img, .battle-image img, .promotion-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .battle-btn-primary {
            flex: 1;
            padding: 8px 12px;
            background: #4a5568;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .battle-btn-primary:hover {
            background: #718096;
        }

        .battle-btn-secondary {
            flex: 1;
            padding: 8px 12px;
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: background 0.2s;
        }

        .battle-btn-secondary:hover {
            background: #4a5568;
        }

        .battle-btn-joined {
            flex: 1;
            padding: 8px 12px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .mystery-box:hover .box-image img, .inventory-item:hover .item-image img,
        .battle-item:hover .battle-image img, .promotion-item:hover .promotion-image img {
            transform: scale(1.1);
        }
        
        /* Gradient overlay matching whitelabel */
        .box-image::after, .item-image::after, .battle-image::after, .promotion-image::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.2) 50%, transparent 100%);
        }
        
        /* Content areas matching whitelabel CaseCard p-2 */
        .box-content, .item-content, .battle-content, .promotion-content {
            padding: 0.5rem;
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        /* Titles matching whitelabel CaseCard text-sm font-bold */
        .box-name, .item-name, .battle-name, .promotion-name {
            font-size: 0.875rem;
            font-weight: 700;
            color: #f8fafc;
            line-height: 1.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 0.5rem;
        }
        
        /* Prices matching whitelabel CaseCard text-primary font-bold */
        .box-price, .item-price, .battle-price, .promotion-value {
            color: hsl(var(--primary));
            font-size: 0.875rem;
            font-weight: 700;
        }
        
        /* Action buttons matching whitelabel CaseCard button-gradient */
        .open-button, .action-button, .join-button, .claim-button {
            background: linear-gradient(135deg, hsl(var(--primary)) 0%, hsl(var(--primary) / 0.8) 100%);
            border: none;
            border-radius: 0.375rem;
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0.25rem 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .open-button:hover, .action-button:hover, .join-button:hover, .claim-button:hover {
            opacity: 0.9;
        }
        
        /* Rarity badges matching whitelabel Badge component */
        .rarity-badge {
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            z-index: 20;
            backdrop-filter: blur(8px);
            border: 1px solid currentColor;
        }
        
        .status-bar {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }
        
        .inventory-controls {
            display: flex;
            gap: 16px;
            margin-bottom: 25px;
            align-items: center;
        }
        
        .search-box {
            flex: 1;
        }
        
        .search-box input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(21, 23, 41, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .search-box input::placeholder {
            color: #888;
        }
        
        .search-box input:focus {
            border-color: #4F86F7;
            box-shadow: 0 0 0 2px rgba(79, 134, 247, 0.2);
        }
        
        .filter-dropdown select {
            padding: 12px 16px;
            background: rgba(21, 23, 41, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            min-width: 150px;
        }
        
        .inventory-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }
        
        .inventory-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .inventory-card:hover {
            transform: translateY(-2px);
            background: rgba(15, 23, 42, 0.9);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .item-icon {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            margin-bottom: 8px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .item-icon.legendary {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
        }
        
        .item-icon.epic {
            background: linear-gradient(135deg, #8b5cf6, #a855f7);
        }
        
        .item-icon.rare {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .item-icon.common {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }
        
        .item-details {
            text-align: left;
        }
        
        .item-details h4 {
            color: white;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 6px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1.2;
        }
        
        .item-rarity-badge {
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            color: white;
            display: inline-block;
            letter-spacing: 0.5px;
        }
        
        .item-rarity-badge.legendary {
            background: #ff6b35;
        }
        
        .item-rarity-badge.epic {
            background: #8b5cf6;
        }
        
        .item-rarity-badge.rare {
            background: #10b981;
        }
        
        .item-rarity-badge.common {
            background: #6b7280;
        }
        
        .status-connected {
            color: #22c55e;
            font-weight: bold;
        }
        
        .status-error {
            color: #ef4444;
            font-weight: bold;
        }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #FF6B35;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .result-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .result-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid #FF6B35;
            max-width: 400px;
            width: 90%;
        }
        
        .result-item {
            font-size: 1.3em;
            color: #FF6B35;
            margin: 15px 0;
        }
        
        .close-button {
            background: #0079F2;
            border: none;
            padding: 8px 25px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .box-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 15px;
            }
            
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="widget-container">
        <div class="header">
            <h1>Mystery Boxes</h1>
            <p>Discover amazing prizes in our premium mystery boxes</p>
        </div>
        
        <div class="nav-menu">
            <div class="nav-items">
                <div class="nav-item active" onclick="showSection('boxes')" data-section="boxes">üì¶ Boxes</div>
                <div class="nav-item" onclick="showSection('inventory')" data-section="inventory">üéí Inventory</div>
                <div class="nav-item" onclick="showSection('market')" data-section="market">üè™ Market</div>
                <div class="nav-item" onclick="showSection('battles')" data-section="battles">‚öîÔ∏è Battles</div>
                <div class="nav-item" onclick="showSection('statistics')" data-section="statistics">üìä Statistics</div>
                <div class="nav-item" onclick="showSection('promotions')" data-section="promotions">üéÅ Promotions</div>
                <div class="nav-item" onclick="showSection('leaderboards')" data-section="leaderboards">üèÜ Leaderboards</div>
                <div class="nav-item" onclick="showSection('achievements')" data-section="achievements">üèÖ Achievements</div>
            </div>
        </div>
        

        
        <!-- Boxes Section -->
        <div id="boxesSection" class="content-section active">
            <div id="boxGrid" class="box-grid">
                <div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">
                    <div class="loading"></div>
                    <p style="margin-top: 10px;">Loading mystery boxes...</p>
                </div>
            </div>
        </div>

        <!-- Inventory Section -->
        <div id="inventorySection" class="content-section">
            <div class="inventory-header">
                <h2>Your Inventory</h2>
                <p>Manage and view all your collected items</p>
            </div>
            
            <!-- Statistics Cards -->
            <div class="inventory-stats">
                <div class="stat-card">
                    <h3>Total Items</h3>
                    <div class="stat-number">10</div>
                </div>
                <div class="stat-card">
                    <h3>Unique Items</h3>
                    <div class="stat-number">10</div>
                </div>
                <div class="stat-card">
                    <h3>Rarest Item</h3>
                    <div class="rarest-item">
                        <div class="rarest-icon legendary"></div>
                        <div class="rarest-info">
                            <div class="rarest-name">Samsung Galaxy S23 Ultra 512GB</div>
                            <div class="rarest-rarity">LEGENDARY</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Search and Filter -->
            <div class="inventory-controls">
                <div class="search-box">
                    <input type="text" placeholder="Search items..." id="inventorySearch">
                </div>
                <div class="filter-dropdown">
                    <select id="rarityFilter">
                        <option value="">All Rarities</option>
                        <option value="legendary">Legendary</option>
                        <option value="epic">Epic</option>
                        <option value="rare">Rare</option>
                        <option value="common">Common</option>
                    </select>
                </div>
            </div>
            
            <!-- Inventory Grid -->
            <div class="inventory-items-grid">
                <div class="inventory-card rarity-legendary">
                    <div class="item-icon legendary"></div>
                    <div class="item-details">
                        <h4>Samsung Gala...</h4>
                        <div class="item-rarity-badge legendary">LEGENDARY</div>
                    </div>
                </div>
                <div class="inventory-card rarity-rare">
                    <div class="item-icon rare"></div>
                    <div class="item-details">
                        <h4>Coral Reef Nec...</h4>
                        <div class="item-rarity-badge rare">RARE</div>
                    </div>
                </div>
                <div class="inventory-card rarity-legendary">
                    <div class="item-icon legendary"></div>
                    <div class="item-details">
                        <h4>Galaxy Crystal...</h4>
                        <div class="item-rarity-badge legendary">LEGENDARY</div>
                    </div>
                </div>
                <div class="inventory-card rarity-epic">
                    <div class="item-icon epic"></div>
                    <div class="item-details">
                        <h4>RGB Gaming ...</h4>
                        <div class="item-rarity-badge epic">EPIC</div>
                    </div>
                </div>
                <div class="inventory-card rarity-epic">
                    <div class="item-icon epic"></div>
                    <div class="item-details">
                        <h4>RGB Gaming ...</h4>
                        <div class="item-rarity-badge epic">EPIC</div>
                    </div>
                </div>
                <div class="inventory-card rarity-common">
                    <div class="item-icon common"></div>
                    <div class="item-details">
                        <h4>Samsung Gala...</h4>
                        <div class="item-rarity-badge common">COMMON</div>
                    </div>
                </div>
                <div class="inventory-card rarity-epic">
                    <div class="item-icon epic"></div>
                    <div class="item-details">
                        <h4>iPad Air 11-inc...</h4>
                        <div class="item-rarity-badge epic">EPIC</div>
                    </div>
                </div>
                <div class="inventory-card rarity-rare">
                    <div class="item-icon rare"></div>
                    <div class="item-details">
                        <h4>AirPods 3rd G...</h4>
                        <div class="item-rarity-badge rare">RARE</div>
                    </div>
                </div>
                <div class="inventory-card rarity-common">
                    <div class="item-icon common"></div>
                    <div class="item-details">
                        <h4>Apple 20W US...</h4>
                        <div class="item-rarity-badge common">COMMON</div>
                    </div>
                </div>
                <div class="inventory-card rarity-epic">
                    <div class="item-icon epic"></div>
                    <div class="item-details">
                        <h4>Off-White Indu...</h4>
                        <div class="item-rarity-badge epic">EPIC</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Market Section -->
        <div id="marketSection" class="content-section">
            <div class="section-header">
                <h2>üè™ Marketplace</h2>
                <p>Buy and sell items with other players</p>
            </div>
            <div class="market-grid">
                <div class="market-item rarity-mythical">
                    <div class="item-image">üì±</div>
                    <div class="item-info">
                        <h4>iPhone 15 Pro</h4>
                        <div class="item-price">$899.99</div>
                        <div class="item-rarity mythical">Mythical</div>
                        <div class="seller">Seller: ProGamer123</div>
                    </div>
                    <button class="buy-btn">Buy Now</button>
                </div>
                <div class="market-item rarity-epic">
                    <div class="item-image">üíé</div>
                    <div class="item-info">
                        <h4>Diamond Ring</h4>
                        <div class="item-price">$1,250.00</div>
                        <div class="item-rarity epic">Epic</div>
                        <div class="seller">Seller: LuxuryDealer</div>
                    </div>
                    <button class="buy-btn">Buy Now</button>
                </div>
                <div class="market-item rarity-rare">
                    <div class="item-image">üé∏</div>
                    <div class="item-info">
                        <h4>Electric Guitar</h4>
                        <div class="item-price">$650.00</div>
                        <div class="item-rarity rare">Rare</div>
                        <div class="seller">Seller: MusicMaster</div>
                    </div>
                    <button class="buy-btn">Buy Now</button>
                </div>
                <div class="market-item rarity-common">
                    <div class="item-image">üéÆ</div>
                    <div class="item-info">
                        <h4>Gaming Controller</h4>
                        <div class="item-price">$45.99</div>
                        <div class="item-rarity common">Common</div>
                        <div class="seller">Seller: GamerBoy</div>
                    </div>
                    <button class="buy-btn">Buy Now</button>
                </div>
            </div>
        </div>

        <!-- Battles Section -->
        <div id="battlesSection" class="content-section">
            <div class="section-header">
                <h2>‚öîÔ∏è Case Battles</h2>
                <p>Compete against other players</p>
            </div>
            <div class="battles-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; padding: 20px 0;">
                <div style="text-align: center; padding: 40px; color: #888;">Loading battles...</div>
            </div>
        </div>

        <!-- Statistics Section -->
        <div id="statisticsSection" class="content-section">
            <div class="section-header">
                <h2>üìä Your Statistics</h2>
                <p>Track your progress and performance</p>
            </div>
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>Boxes Opened</h3>
                    <div class="stat-value">247</div>
                </div>
                <div class="stat-card">
                    <h3>Total Value Won</h3>
                    <div class="stat-value">$12,430.50</div>
                </div>
                <div class="stat-card">
                    <h3>Rare Items</h3>
                    <div class="stat-value">18</div>
                </div>
                <div class="stat-card">
                    <h3>Epic Items</h3>
                    <div class="stat-value">5</div>
                </div>
                <div class="stat-card">
                    <h3>Win Rate</h3>
                    <div class="stat-value">73%</div>
                </div>
                <div class="stat-card">
                    <h3>Current Streak</h3>
                    <div class="stat-value">12</div>
                </div>
            </div>
        </div>

        <!-- Promotions Section -->
        <div id="promotionsSection" class="content-section">
            <div class="section-header">
                <h2>üéÅ Promotions</h2>
                <p>Special offers and bonuses</p>
            </div>
            <div class="promotions-grid">
                <div class="promo-item featured">
                    <div class="promo-header">
                        <h4>üî• Welcome Bonus</h4>
                        <div class="promo-badge active">ACTIVE</div>
                    </div>
                    <div class="promo-description">
                        Get 100% bonus on your first deposit up to $500!
                    </div>
                    <div class="promo-details">
                        <div class="promo-code">Code: WELCOME100</div>
                        <div class="promo-expires">Expires: Never</div>
                    </div>
                    <button class="claim-btn">Claim Now</button>
                </div>
                <div class="promo-item">
                    <div class="promo-header">
                        <h4>üíé VIP Weekend</h4>
                        <div class="promo-badge limited">LIMITED</div>
                    </div>
                    <div class="promo-description">
                        50% extra rewards on all premium box openings this weekend
                    </div>
                    <div class="promo-details">
                        <div class="promo-code">Code: VIPWEEKEND</div>
                        <div class="promo-expires">Expires: 2 days</div>
                    </div>
                    <button class="claim-btn">Claim Now</button>
                </div>
                <div class="promo-item">
                    <div class="promo-header">
                        <h4>üèÜ Daily Login</h4>
                        <div class="promo-badge daily">DAILY</div>
                    </div>
                    <div class="promo-description">
                        Login daily for 7 days to unlock exclusive rewards
                    </div>
                    <div class="promo-details">
                        <div class="promo-progress">Progress: 4/7 days</div>
                        <div class="promo-reward">Reward: Epic Box</div>
                    </div>
                    <button class="progress-btn">Continue</button>
                </div>
            </div>
        </div>

        <!-- Leaderboards Section -->
        <div id="leaderboardsSection" class="content-section">
            <div class="section-header">
                <h2>üèÜ Leaderboards</h2>
                <p>See how you rank against other players</p>
            </div>
            <!-- Leaderboard Tabs -->
            <div class="leaderboard-tabs" style="display: flex; gap: 8px; margin-bottom: 24px; justify-content: center;">
                <button class="tab-button active" data-tab="spending" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-weight: 600;">Total Spent</button>
                <button class="tab-button" data-tab="cases" style="padding: 8px 16px; background: #374151; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">Cases Opened</button>
                <button class="tab-button" data-tab="rare_items" style="padding: 8px 16px; background: #374151; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">Rare Items</button>
            </div>
            
            <div class="leaderboard-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px;">
                <div style="text-align: center; padding: 40px; color: #888; grid-column: 1/-1;">Loading leaderboards...</div>
            </div>
        </div>

        <!-- Achievements Section -->
        <div id="achievementsSection" class="content-section">
            <div class="section-header">
                <h2>üèÖ Achievements</h2>
                <p>Unlock rewards for your accomplishments</p>
            </div>
            <div class="achievements-grid">
                <div class="achievement-item completed">
                    <div class="achievement-icon">üéØ</div>
                    <div class="achievement-info">
                        <h4>First Steps</h4>
                        <p>Open your first mystery box</p>
                        <div class="achievement-reward">Reward: $10 Bonus</div>
                        <div class="achievement-status completed">COMPLETED</div>
                    </div>
                </div>
                <div class="achievement-item completed">
                    <div class="achievement-icon">üíØ</div>
                    <div class="achievement-info">
                        <h4>Century Club</h4>
                        <p>Open 100 mystery boxes</p>
                        <div class="achievement-reward">Reward: Epic Box</div>
                        <div class="achievement-status completed">COMPLETED</div>
                    </div>
                </div>
                <div class="achievement-item in-progress">
                    <div class="achievement-icon">üî•</div>
                    <div class="achievement-info">
                        <h4>Hot Streak</h4>
                        <p>Win from 20 consecutive boxes</p>
                        <div class="achievement-progress">Progress: 12/20</div>
                        <div class="achievement-reward">Reward: Mythical Box</div>
                        <div class="achievement-status progress">IN PROGRESS</div>
                    </div>
                </div>
                <div class="achievement-item locked">
                    <div class="achievement-icon">üëë</div>
                    <div class="achievement-info">
                        <h4>Box Royalty</h4>
                        <p>Open 1000 mystery boxes</p>
                        <div class="achievement-progress">Progress: 247/1000</div>
                        <div class="achievement-reward">Reward: Crown Title</div>
                        <div class="achievement-status locked">LOCKED</div>
                    </div>
                </div>
                <div class="achievement-item locked">
                    <div class="achievement-icon">üíé</div>
                    <div class="achievement-info">
                        <h4>Diamond Hunter</h4>
                        <p>Find 10 mythical items</p>
                        <div class="achievement-progress">Progress: 2/10</div>
                        <div class="achievement-reward">Reward: Diamond Badge</div>
                        <div class="achievement-status locked">LOCKED</div>
                    </div>
                </div>
                <div class="achievement-item locked">
                    <div class="achievement-icon">‚ö°</div>
                    <div class="achievement-info">
                        <h4>Speed Demon</h4>
                        <p>Open 50 boxes in one day</p>
                        <div class="achievement-progress">Progress: 0/50</div>
                        <div class="achievement-reward">Reward: Lightning Effect</div>
                        <div class="achievement-status locked">LOCKED</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="resultPopup" class="result-popup">
        <div class="result-content">
            <h3>Box Opened!</h3>
            <div id="resultItem" class="result-item">Loading...</div>
            <div id="resultRarity"></div>
            <button class="close-button" onclick="closePopup()">Continue</button>
        </div>
    </div>
    
    <script>
        // Extract partner from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const partnerParam = urlParams.get('partner') || 'test';
        
        // Map partner names to API keys
        const partnerApiKeys = {
            'test': 'test',
            'rolling-riches': 'rolling-riches',
            'default': 'test'
        };
        
        const apiConfig = {
            endpoint: window.location.origin,
            apiKey: partnerApiKeys[partnerParam] || partnerApiKeys['default'],
            partner: partnerParam
        };
        
        console.log('Partner widget loaded for:', partnerParam, 'with API key:', apiConfig.apiKey);
        
        // PostMessage communication with parent window
        let isFullscreen = false;
        
        function toggleFullscreen(enable) {
            isFullscreen = enable;
            const body = document.body;
            const container = document.querySelector('.widget-container');
            const navbar = document.querySelector('.nav-menu');
            
            if (enable) {
                body.classList.add('fullscreen');
                container.classList.add('fullscreen');
                if (navbar) navbar.classList.add('fullscreen');
            } else {
                body.classList.remove('fullscreen');
                container.classList.remove('fullscreen');
                if (navbar) navbar.classList.remove('fullscreen');
            }
            
            // Notify parent of fullscreen state change
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'fullscreenChanged',
                    fullscreen: enable,
                    source: 'rolling-drop-widget'
                }, '*');
            }
        }
        
        // Listen for messages from parent window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.source === 'rolling-drop-parent') {
                switch(event.data.type) {
                    case 'setFullscreen':
                        toggleFullscreen(event.data.fullscreen);
                        break;
                    case 'navigateToSection':
                        showSection(event.data.section);
                        break;
                    case 'getState':
                        // Send current state to parent
                        event.source.postMessage({
                            type: 'stateResponse',
                            fullscreen: isFullscreen,
                            currentSection: getCurrentSection(),
                            source: 'rolling-drop-widget'
                        }, event.origin);
                        break;
                }
            }
        });
        
        function getCurrentSection() {
            const activeNav = document.querySelector('.nav-item.active');
            return activeNav ? activeNav.getAttribute('data-section') : 'boxes';
        }
        
        // Notify parent when widget is ready
        window.addEventListener('load', function() {
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'widgetReady',
                    partner: partnerParam,
                    source: 'rolling-drop-widget'
                }, '*');
            }
        });
        
        function getFullImageUrl(imageUrl) {
            if (!imageUrl) return '';
            if (imageUrl.startsWith('http')) return imageUrl;
            const fullUrl = window.location.origin + imageUrl;
            console.log('Converting image URL:', imageUrl, 'to:', fullUrl);
            return fullUrl;
        }
        
        async function apiRequest(endpoint, options = {}) {
            const url = apiConfig.endpoint + endpoint;
            const headers = {
                'Content-Type': 'application/json',
                'X-API-Key': apiConfig.apiKey,
                ...options.headers
            };
            
            const response = await fetch(url, { ...options, headers });
            if (!response.ok) {
                throw new Error('HTTP ' + response.status + ': ' + response.statusText);
            }
            return await response.json();
        }
        
        function showSection(sectionName) {
            // Hide all content sections
            const sections = document.querySelectorAll('.content-section');
            sections.forEach(section => section.classList.remove('active'));
            
            // Remove active class from all nav items and add to clicked item
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach(item => {
                item.classList.remove('active');
                if (item.getAttribute('data-section') === sectionName) {
                    item.classList.add('active');
                }
            });
            
            // Show the selected section
            const targetSection = document.getElementById(sectionName + 'Section');
            if (targetSection) {
                targetSection.classList.add('active');
            }
            
            // Load section-specific content
            loadSectionContent(sectionName);
        }
        
        function loadSectionContent(sectionName) {
            switch(sectionName) {
                case 'boxes':
                    loadBoxes();
                    break;
                case 'inventory':
                    loadInventory();
                    break;
                case 'battles':
                    loadBattles();
                    break;
                case 'statistics':
                    loadStatistics();
                    break;
                default:
                    // Other sections will be implemented later
                    break;
            }
        }
        
        async function loadInventory() {
            console.log('Loading inventory...');
            const inventoryGrid = document.getElementById('inventorySection').querySelector('.inventory-items-grid');
            const statsCards = document.getElementById('inventorySection').querySelectorAll('.stat-number, .rarest-name, .rarest-rarity');
            
            try {
                // Generate a unique external user ID for this partner session
                const externalUserId = '${partner || 'b2b'}_user_' + Date.now();
                
                const result = await apiRequest('/api/partner/v1/inventory?externalUserId=' + externalUserId);
                console.log('Inventory loaded successfully:', result);
                
                if (result && result.inventory && Array.isArray(result.inventory)) {
                    displayInventory(result.inventory, result.stats);
                } else {
                    inventoryGrid.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">No inventory items found</div>';
                }
            } catch (error) {
                console.error('Failed to load inventory:', error);
                inventoryGrid.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Failed to load inventory: ' + error.message + '</div>';
            }
        }
        
        function displayInventory(items, stats) {
            const inventoryGrid = document.getElementById('inventorySection').querySelector('.inventory-items-grid');
            
            // Update stats
            const statNumbers = document.getElementById('inventorySection').querySelectorAll('.stat-number');
            if (statNumbers.length >= 2) {
                statNumbers[0].textContent = stats.totalItems || 0;
                statNumbers[1].textContent = stats.uniqueItems || 0;
            }
            
            if (stats.rarestItem) {
                const rarestName = document.getElementById('inventorySection').querySelector('.rarest-name');
                const rarestRarity = document.getElementById('inventorySection').querySelector('.rarest-rarity');
                if (rarestName) rarestName.textContent = stats.rarestItem.name;
                if (rarestRarity) rarestRarity.textContent = stats.rarestItem.rarity.toUpperCase();
            }
            
            if (!items.length) {
                inventoryGrid.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">No items in inventory</div>';
                return;
            }
            
            // Display inventory items with rarity colors
            inventoryGrid.innerHTML = items.map(function(item) {
                const rarityMap = {
                    'common': { bg: 'bg-gray-600', text: 'text-gray-100' },
                    'uncommon': { bg: 'bg-blue-600', text: 'text-blue-100' },
                    'rare': { bg: 'bg-green-600', text: 'text-green-100' },
                    'epic': { bg: 'bg-purple-600', text: 'text-purple-100' },
                    'legendary': { bg: 'bg-orange-600', text: 'text-orange-100' },
                    'mythical': { bg: 'bg-red-600', text: 'text-red-100' }
                };
                const rarity = rarityMap[item.rarity] || rarityMap['common'];
                
                return '<div class="inventory-item rarity-' + item.rarity + '" data-rarity="' + item.rarity + '">' +
                    '<div class="item-icon ' + item.rarity + '" style="background: ' + 
                        (item.rarity === 'common' ? '#6B7280' :
                         item.rarity === 'uncommon' ? '#3B82F6' :
                         item.rarity === 'rare' ? '#10B981' :
                         item.rarity === 'epic' ? '#8B5CF6' :
                         item.rarity === 'legendary' ? '#F59E0B' :
                         '#EF4444') + 
                    '"></div>' +
                    '<div class="item-details">' +
                        '<h4 title="' + item.name + '">' + (item.name.length > 15 ? item.name.substring(0, 12) + '...' : item.name) + '</h4>' +
                        '<div class="item-rarity-badge ' + item.rarity + '">' + item.rarity.toUpperCase() + '</div>' +
                        (item.quantity > 1 ? '<div class="item-quantity">x' + item.quantity + '</div>' : '') +
                    '</div>' +
                '</div>';
            }).join('');
        }
        
        async function loadBattles() {
            console.log('Loading battles...');
            const battlesContainer = document.getElementById('battlesSection').querySelector('.battles-grid');
            
            if (!battlesContainer) {
                console.error('Battles container not found');
                return;
            }
            
            try {
                console.log('Making API request to /api/partner/v1/battles');
                const result = await apiRequest('/api/partner/v1/battles');
                console.log('Battles API response:', result);
                
                if (result && result.battles && Array.isArray(result.battles)) {
                    console.log('Displaying', result.battles.length, 'battles');
                    displayBattles(result.battles);
                } else {
                    console.log('No battles found in response');
                    battlesContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #ef4444;">No active battles found</div>';
                }
            } catch (error) {
                console.error('Failed to load battles:', error);
                console.error('Error details:', error.message, error.stack);
                battlesContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #ef4444;">Failed to load battles: ' + (error.message || 'Unknown error') + '</div>';
            }
        }
        
        function displayBattles(battles) {
            const battlesContainer = document.getElementById('battlesSection').querySelector('.battles-grid');
            
            if (!battles.length) {
                battlesContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No battles available</div>';
                return;
            }
            
            // Apply exact whitelabel grid styling
            battlesContainer.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; padding: 0;';
            
            battlesContainer.innerHTML = battles.map(function(battle, index) {
                const statusColor = battle.status === 'LIVE' || battle.status === 'ACTIVE' ? '#ef4444' : '#3b82f6';
                const statusText = battle.status === 'LIVE' || battle.status === 'ACTIVE' ? 'ACTIVE' : 'WAITING';
                
                // Map battle names to match whitelabel format
                const battleNames = ['Battle #1', 'Battle #2', 'Battle #3', 'Battle #4', 'Battle #5', 'Battle #6', 'Battle #7'];
                const battleName = battleNames[index] || 'Battle #' + (index + 1);
                const battleSubtitle = ['Epic Battle', 'Gold Finger', 'Updated Battle', 'Updated Battle', 'Epic Battle', 'Challenge Battle', 'Updated Battle'][index] || 'Epic Battle';
                
                return '<div style="background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); border: 1px solid #4a5568; border-radius: 12px; padding: 20px; position: relative; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">' +
                    
                    // Battle icon and header
                    '<div style="display: flex; align-items: flex-start; gap: 8px; margin-bottom: 8px;">' +
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2" style="margin-top: 2px;"><path d="M6.5 6.5l11 11m-11 0l11-11"/></svg>' +
                        '<span style="color: white; font-weight: 600; font-size: 14px; line-height: 1.2;">' + battleName + '</span>' +
                        '<span style="margin-left: auto; padding: 3px 8px; background: ' + statusColor + '; color: white; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase;">' + statusText + '</span>' +
                    '</div>' +
                    
                    // Battle subtitle
                    '<div style="color: #9ca3af; font-size: 12px; margin-bottom: 12px; margin-left: 24px;">' + battleSubtitle + '</div>' +
                    '<div style="color: #9ca3af; font-size: 12px; margin-bottom: 16px; margin-left: 24px;">Box: ' + (battle.boxName || 'Celestial Guardian') + '</div>' +
                    
                    // Player count and rounds
                    '<div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px; margin-left: 24px; font-size: 12px;">' +
                        '<div style="display: flex; align-items: center; gap: 6px; color: #d1d5db;">' +
                            '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>' +
                            '<span>' + battle.playerCount + ' Players</span>' +
                        '</div>' +
                        '<div style="display: flex; align-items: center; gap: 6px; color: #d1d5db;">' +
                            '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>' +
                            '<span>' + (battle.rounds || 3) + ' Rounds</span>' +
                        '</div>' +
                    '</div>' +
                    
                    // Entry fee section
                    '<div style="margin-bottom: 16px; margin-left: 24px;">' +
                        '<div style="display: flex; align-items: center; gap: 6px;">' +
                            '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2"><path d="M12 2v20m5-5H7a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2z"/></svg>' +
                            '<span style="color: #10b981; font-size: 12px; font-weight: 600;">' + battle.entryFee + ' Entry</span>' +
                        '</div>' +
                    '</div>' +
                    
                    // Action buttons
                    '<div style="display: flex; gap: 10px; margin-left: 24px;">' +
                        (battle.status === 'WAITING' ? 
                            '<button class="battle-btn-primary">üë§ Your Battle</button>' +
                            '<button class="battle-btn-secondary">üëÅÔ∏è View</button>'
                            :
                            '<button class="battle-btn-joined">‚úì Joined</button>' +
                            '<button class="battle-btn-secondary">üëÅÔ∏è View</button>'
                        ) +
                    '</div>' +
                '</div>';
            }).join('');
        }

        async function loadStatistics() {
            // Placeholder for statistics loading
            console.log('Loading statistics...');
        }

        async function loadLeaderboards(type = 'spending') {
            console.log('Loading leaderboards for type:', type);
            const leaderboardGrid = document.querySelector('.leaderboard-grid');
            
            if (!leaderboardGrid) {
                console.error('Leaderboard grid not found');
                return;
            }
            
            try {
                // Use partner API endpoint based on type
                const endpoint = '/api/partner/v1/leaderboard/' + type;
                console.log('Making API request to:', endpoint);
                
                const result = await apiRequest(endpoint);
                console.log('Leaderboard API response:', result);
                
                if (result && result.leaderboard && Array.isArray(result.leaderboard)) {
                    displayLeaderboard(result.leaderboard, type);
                } else if (result && Array.isArray(result)) {
                    displayLeaderboard(result, type);
                } else {
                    console.log('No leaderboard data found');
                    leaderboardGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: #888; grid-column: 1/-1;">No leaderboard data available</div>';
                }
            } catch (error) {
                console.error('Failed to load leaderboards:', error);
                // Show static data matching whitelabel format as fallback
                displayStaticLeaderboard(type);
            }
        }

        function displayLeaderboard(leaderboard, type) {
            const leaderboardGrid = document.querySelector('.leaderboard-grid');
            
            if (!leaderboard.length) {
                leaderboardGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: #888; grid-column: 1/-1;">No players yet</div>';
                return;
            }
            
            const formatValue = (value, entryType) => {
                if (entryType === 'spending') return '$' + (value || '0');
                if (entryType === 'cases') return (value || '0') + ' cases';
                if (entryType === 'rare_items') return (value || '0') + ' rare items';
                return value || '0';
            };
            
            leaderboardGrid.innerHTML = leaderboard.slice(0, 6).map((player, index) => {
                const rank = index + 1;
                const rankBadgeClass = rank === 1 ? 'legendary' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                
                return '<div class="mystery-box">' +
                    '<div class="box-image">' +
                        '<img src="' + (player.avatar || 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=300&h=300&fit=crop&crop=face') + '" alt="' + (player.username || 'Player') + '" />' +
                        '<div class="rarity-badge ' + rankBadgeClass + '">#' + rank + '</div>' +
                    '</div>' +
                    '<div class="box-content">' +
                        '<div class="box-name">' + (player.username || 'Player ' + rank) + '</div>' +
                        '<div class="box-price">' + formatValue(player.value || player.totalSpent || player.casesOpened || player.rareItems, type) + '</div>' +
                        '<button class="open-button">View Profile</button>' +
                    '</div>' +
                '</div>';
            }).join('');
        }

        function displayStaticLeaderboard(type) {
            const leaderboardGrid = document.querySelector('.leaderboard-grid');
            
            // Static data matching whitelabel format
            const staticData = [
                { username: 'CryptoKing', value: '$15,420', avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=300&h=300&fit=crop&crop=face' },
                { username: 'LuckyStrike', value: '$12,890', avatar: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=100&h=100&fit=crop&crop=face' },
                { username: 'BoxMaster', value: '$9,750', avatar: 'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=100&h=100&fit=crop&crop=face' }
            ];
            
            leaderboardGrid.innerHTML = staticData.map((player, index) => {
                const rank = index + 1;
                const rankBadgeClass = rank === 1 ? 'legendary' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                
                return '<div class="mystery-box">' +
                    '<div class="box-image">' +
                        '<img src="' + player.avatar + '" alt="' + player.username + '" />' +
                        '<div class="rarity-badge ' + rankBadgeClass + '">#' + rank + '</div>' +
                    '</div>' +
                    '<div class="box-content">' +
                        '<div class="box-name">' + player.username + '</div>' +
                        '<div class="box-price">' + player.value + '</div>' +
                        '<button class="open-button">View Profile</button>' +
                    '</div>' +
                '</div>';
            }).join('');
        }

        // Tab switching functionality
        function setupLeaderboardTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all tabs
                    tabButtons.forEach(btn => {
                        btn.classList.remove('active');
                        btn.style.background = '#374151';
                    });
                    
                    // Add active class to clicked tab
                    button.classList.add('active');
                    button.style.background = button.dataset.tab === 'spending' ? '#10b981' : 
                                            button.dataset.tab === 'cases' ? '#3b82f6' : '#8b5cf6';
                    
                    // Load leaderboard for selected type
                    loadLeaderboards(button.dataset.tab);
                });
            });
        }
        
        async function loadBoxes() {
            const gridEl = document.getElementById('boxGrid');
            
            try {
                console.log('Starting to load boxes...');
                const result = await apiRequest('/api/partner/v1/boxes');
                console.log('Boxes loaded successfully:', result);
                
                if (result && result.boxes && Array.isArray(result.boxes)) {
                    displayBoxes(result.boxes);
                } else if (result && Array.isArray(result)) {
                    displayBoxes(result);
                } else {
                    console.error('Invalid response format:', result);
                    gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Invalid data format received</div>';
                }
            } catch (error) {
                console.error('Failed to load boxes:', error);
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #ef4444;">Failed to load mystery boxes: ' + error.message + '</div>';
            }
        }
        
        function displayBoxes(boxes) {
            const gridEl = document.getElementById('boxGrid');
            
            if (!boxes.length) {
                gridEl.innerHTML = '<div style="text-align: center; grid-column: 1/-1; padding: 40px; color: #888;">No mystery boxes available</div>';
                return;
            }
            
            // Show featured boxes first, then others, limit to 12 for iframe
            const featuredBoxes = boxes.filter(function(box) { return box.featured; }).slice(0, 6);
            const otherBoxes = boxes.filter(function(box) { return !box.featured; }).slice(0, 6);
            const displayBoxes = featuredBoxes.concat(otherBoxes).slice(0, 12);
            
            gridEl.innerHTML = displayBoxes.map(function(box) {
                const imageUrl = getFullImageUrl(box.imageUrl);
                // Map rarity to actual CSS classes
                const rarityMap = {
                    'common': { bg: 'bg-gray-600', text: 'text-gray-100', border: 'border-gray-500' },
                    'rare': { bg: 'bg-green-600', text: 'text-green-100', border: 'border-green-500' },
                    'epic': { bg: 'bg-purple-600', text: 'text-purple-100', border: 'border-purple-500' },
                    'legendary': { bg: 'bg-orange-600', text: 'text-orange-100', border: 'border-orange-500' },
                    'mythical': { bg: 'bg-red-600', text: 'text-red-100', border: 'border-red-500' }
                };
                const rarity = rarityMap[box.rarity] || rarityMap['common'];
                const rarityBorder = rarity.border;
                const rarityBg = rarity.bg;
                const rarityText = rarity.text;
                const rarityGlow = 'rarity-glow-' + box.rarity;
                console.log('Box:', box.name, 'Image URL:', imageUrl);
                
                return '<div class="mystery-box group cursor-pointer" data-rarity="' + box.rarity + '" onclick="openBox(' + box.id + ')">' +
                    '<div class="relative overflow-hidden rounded-xl glass-effect border card-hover ' + rarityBorder + ' ' + rarityGlow + '">' +
                        '<div class="absolute top-0 left-0 right-0 h-1 ' + rarityBg + '"></div>' +
                        '<div class="absolute inset-0 animate-shimmer opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>' +
                        '<div class="aspect-square overflow-hidden relative">' +
                            '<img src="' + imageUrl + '" alt="' + box.name + '" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" />' +
                            '<div class="absolute inset-0 bg-gradient-to-t from-black/60 via-black/20 to-transparent"></div>' +
                            '<div class="absolute top-2 right-2 flex flex-col gap-2 items-end">' +
                                '<div class="' + rarityBg + ' ' + rarityText + ' backdrop-blur-sm font-bold px-2 py-1 rounded text-xs border border-white/20">' +
                                    box.rarity.toUpperCase() +
                                '</div>' +
                                '<button class="w-8 h-8 p-0 rounded-full backdrop-blur-sm bg-black/50 hover:bg-red-500/90 text-white/70 hover:text-white transition-all duration-300 flex items-center justify-center">' +
                                    '<svg class="w-4 h-4 hover:scale-110 transition-all duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>' +
                                '</button>' +
                            '</div>' +
                        '</div>' +
                        '<div class="p-2 relative z-10">' +
                            '<div class="flex items-center justify-between mb-1">' +
                                '<h3 class="text-sm font-bold text-card-foreground group-hover:text-primary transition-colors truncate flex-1 mr-2">' +
                                    box.name +
                                '</h3>' +
                            '</div>' +
                            '<div class="flex items-center justify-between mt-2">' +
                                '<div class="text-sm font-bold text-primary">$' + box.price + '</div>' +
                                '<div class="flex gap-1">' +
                                    '<button class="text-primary border-primary/30 hover:bg-primary/10 p-1 w-6 h-6 rounded border flex items-center justify-center">' +
                                        '<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>' +
                                    '</button>' +
                                    '<button class="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-semibold px-2 py-1 text-xs rounded flex items-center transition-all duration-300" onclick="event.stopPropagation(); openBox(' + box.id + ')">' +
                                        '<svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path></svg>' +
                                        'Open' +
                                    '</button>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="absolute inset-0 rounded-xl opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none" style="box-shadow: 0 0 30px ' + 
                            (box.rarity === 'common' ? 'rgba(148, 163, 184, 0.5)' :
                             box.rarity === 'rare' ? 'rgba(22, 163, 74, 0.5)' :
                             box.rarity === 'epic' ? 'rgba(139, 92, 246, 0.5)' :
                             box.rarity === 'legendary' ? 'rgba(245, 158, 11, 0.5)' :
                             'rgba(239, 68, 68, 0.5)') + 
                        '"></div>' +
                    '</div>' +
                '</div>';
            }).join('');
        }
        
        async function openBox(boxId) {
            const popup = document.getElementById('resultPopup');
            const resultItem = document.getElementById('resultItem');
            const resultRarity = document.getElementById('resultRarity');
            
            popup.style.display = 'flex';
            resultItem.innerHTML = '<div class="loading"></div> Opening box...';
            resultRarity.textContent = '';
            
            try {
                const result = await apiRequest('/api/partner/v1/boxes/' + boxId + '/open', {
                    method: 'POST',
                    body: JSON.stringify({ 
                        externalUserId: '${partner || 'b2b'}_user_' + Date.now(),
                        amount: 1
                    })
                });
                
                if (result.success && result.data && result.data.item) {
                    const item = result.data.item;
                    resultItem.textContent = item.name;
                    resultRarity.innerHTML = '<div class="box-rarity rarity-' + item.rarity + '" style="position: static; margin: 10px auto; display: inline-block;">' +
                        item.rarity +
                        '</div>' +
                        '<div style="margin-top: 10px; color: #0079F2;">' +
                        'Value: $' + item.value + ' | Profit: $' + result.data.transaction.profit +
                        '</div>';
                } else {
                    resultItem.textContent = 'Error opening box';
                    resultRarity.textContent = result.message || 'Unknown error';
                }
            } catch (error) {
                console.error('Failed to open box:', error);
                resultItem.textContent = 'Failed to open box';
                resultRarity.textContent = error.message;
            }
        }
        
        function closePopup() {
            document.getElementById('resultPopup').style.display = 'none';
        }
        
        // Auto-load content when page loads
        window.addEventListener('load', function() {
            loadBoxes();
            setupLeaderboardTabs();
            loadLeaderboards('spending'); // Load default leaderboard
        });
    </script>
</body>
</html>`;

    // Force override all security headers after processing
    res.removeHeader('X-Frame-Options');
    res.removeHeader('Content-Security-Policy');
    res.removeHeader('X-Content-Type-Options');
    res.removeHeader('X-XSS-Protection');
    res.removeHeader('Referrer-Policy');
    res.removeHeader('Permissions-Policy');
    
    // Set iframe-friendly headers
    res.setHeader('X-Frame-Options', 'ALLOWALL');
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');
    
    res.send(iframeHTML);
  });

  // Rate limiting storage for authentication endpoints
  const authAttempts = new Map<string, { count: number; resetTime: number; blockUntil?: number }>();
  const registrationAttempts = new Map<string, { count: number; resetTime: number; blockUntil?: number }>();
  const passwordResetAttempts = new Map<string, { count: number; resetTime: number; blockUntil?: number }>();
  
  // Rate limiting configuration
  const RATE_LIMITS = {
    LOGIN: { maxAttempts: 5, windowMs: 15 * 60 * 1000, blockDurationMs: 30 * 60 * 1000 }, // 5 attempts per 15min, block for 30min
    REGISTRATION: { maxAttempts: 3, windowMs: 60 * 60 * 1000, blockDurationMs: 60 * 60 * 1000 }, // 3 attempts per hour, block for 1 hour
    PASSWORD_RESET: { maxAttempts: 3, windowMs: 60 * 60 * 1000, blockDurationMs: 60 * 60 * 1000 } // 3 attempts per hour, block for 1 hour
  };

  // Generic rate limiting function
  const checkRateLimit = (
    clientIP: string, 
    attemptsMap: Map<string, { count: number; resetTime: number; blockUntil?: number }>,
    config: { maxAttempts: number; windowMs: number; blockDurationMs: number },
    action: string
  ) => {
    const now = Date.now();
    const key = clientIP;
    const attempt = attemptsMap.get(key);

    // Check if currently blocked
    if (attempt?.blockUntil && now < attempt.blockUntil) {
      const remainingTime = Math.ceil((attempt.blockUntil - now) / 1000 / 60); // minutes
      return {
        blocked: true,
        message: `Too many ${action} attempts. Try again in ${remainingTime} minutes.`,
        retryAfter: attempt.blockUntil
      };
    }

    // Initialize or reset if window expired
    if (!attempt || now > attempt.resetTime) {
      attemptsMap.set(key, {
        count: 1,
        resetTime: now + config.windowMs
      });
      return { blocked: false, remaining: config.maxAttempts - 1 };
    }

    // Increment attempts
    attempt.count++;
    
    // Check if limit exceeded
    if (attempt.count > config.maxAttempts) {
      attempt.blockUntil = now + config.blockDurationMs;
      const blockMinutes = Math.ceil(config.blockDurationMs / 1000 / 60);
      return {
        blocked: true,
        message: `Too many ${action} attempts. Blocked for ${blockMinutes} minutes.`,
        retryAfter: attempt.blockUntil
      };
    }

    return { blocked: false, remaining: config.maxAttempts - attempt.count };
  };

  // Security middleware and headers
  app.use((req, res, next) => {
    // Skip security headers entirely for iframe widget routes
    if (req.path === '/iframe_widget.html' || req.path.startsWith('/widget/')) {
      return next();
    }
    
    // Security headers to prevent various attacks
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
    
    // Content Security Policy - Restrictive for non-widget endpoints
    const cspPolicies = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval'", // Required for Vite dev
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https: blob:",
      "font-src 'self' data:",
      "connect-src 'self' ws: wss:",
      "frame-ancestors 'self' https://replit.com https://*.replit.com http://localhost:3000",
      "base-uri 'self'",
      "form-action 'self'"
    ];
    
    res.setHeader('Content-Security-Policy', cspPolicies.join('; '));

    // Rate limiting headers
    res.setHeader('X-RateLimit-Limit', '1000');
    res.setHeader('X-RateLimit-Remaining', '999');
    
    next();
  });

  // Input sanitization middleware already handled by Express

  // Set up authentication middleware
  await setupAuth(app);

  // Admin session storage (in production, use Redis or database)
  const adminSessions = new Map<string, { username: string; loginTime: number }>();

  // Admin authentication middleware - completely separate from player auth
  const requireAdminAuth: RequestHandler = async (req, res, next) => {
    // Check for admin session token
    const adminToken = req.headers['x-admin-token'] as string || (req.session as any)?.adminToken;
    
    if (!adminToken) {
      return res.status(401).json({ message: "Admin authentication required" });
    }

    // Check if session exists and is valid
    const session = adminSessions.get(adminToken);
    if (!session) {
      return res.status(401).json({ message: "Invalid or expired session" });
    }

    // Check if session is expired (24 hours)
    if (Date.now() - session.loginTime > 24 * 60 * 60 * 1000) {
      adminSessions.delete(adminToken);
      return res.status(401).json({ message: "Session expired" });
    }

    req.adminUser = session;
    next();
  };

  // Demo login endpoint for testing
  app.post("/api/demo-login", async (req, res) => {
    try {
      // Set user back to logged in state
      await storage.updateUser(1, { 
        username: "Player_2024",
        usdBalance: "12529.00" 
      });
      console.log("Demo login successful");
      
      res.json({ 
        success: true, 
        message: "Demo login successful"
      });
    } catch (error) {
      console.error("Error with demo login:", error);
      res.status(500).json({ message: "Demo login failed" });
    }
  });

  // Demo logout endpoint that forces a logout state
  app.post("/api/demo-logout", async (req, res) => {
    try {
      // Reset the demo user to logged out state
      await storage.updateUser(1, { username: "LOGGED_OUT" });
      res.clearCookie('connect.sid');
      res.json({ success: true, message: "Logged out successfully" });
    } catch (error) {
      console.error("Error with demo logout:", error);
      res.status(500).json({ message: "Logout failed" });
    }
  });

  // Input validation schema for admin login
  const adminLoginSchema = z.object({
    username: z.string().min(1).max(50).regex(/^[a-zA-Z0-9_]+$/, "Username must contain only alphanumeric characters and underscores"),
    password: z.string().min(8).max(128)
  });

  // Admin authentication routes
  app.post("/api/admin/login", async (req, res) => {
    try {
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      
      // Check rate limit first
      const rateCheck = checkRateLimit(clientIP, authAttempts, RATE_LIMITS.LOGIN, 'login');
      if (rateCheck.blocked) {
        res.setHeader('Retry-After', Math.ceil((rateCheck.retryAfter! - Date.now()) / 1000));
        res.setHeader('X-RateLimit-Blocked', 'true');
        return res.status(429).json({ 
          message: rateCheck.message,
          retryAfter: rateCheck.retryAfter,
          type: 'rate_limit_exceeded'
        });
      }
      
      // Validate input
      const validation = adminLoginSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid input format",
          errors: validation.error.issues 
        });
      }

      const { username, password } = validation.data;

      // Set rate limiting headers
      if (rateCheck.remaining !== undefined) {
        res.setHeader('X-RateLimit-Remaining', rateCheck.remaining.toString());
        res.setHeader('X-RateLimit-Limit', RATE_LIMITS.LOGIN.maxAttempts.toString());
      }

      // Secure credential verification with environment variables
      const adminUsername = process.env.ADMIN_USERNAME || "superadmin";
      const adminPassword = process.env.ADMIN_PASSWORD || "superadmin";

      // Use timing-safe comparison to prevent timing attacks
      // Pad strings to equal length for timingSafeEqual
      const maxUsernameLength = Math.max(username.length, adminUsername.length, 50);
      const maxPasswordLength = Math.max(password.length, adminPassword.length, 100);
      
      const usernameValid = crypto.timingSafeEqual(
        Buffer.from(username.padEnd(maxUsernameLength, '\0')),
        Buffer.from(adminUsername.padEnd(maxUsernameLength, '\0'))
      );
      const passwordValid = crypto.timingSafeEqual(
        Buffer.from(password.padEnd(maxPasswordLength, '\0')),
        Buffer.from(adminPassword.padEnd(maxPasswordLength, '\0'))
      );

      if (usernameValid && passwordValid) {
        // Clear rate limit on successful login
        authAttempts.delete(clientIP);
        
        // Generate cryptographically secure session token
        const sessionToken = crypto.randomBytes(32).toString('hex');
        
        // Store session with additional metadata
        adminSessions.set(sessionToken, {
          username: username,
          loginTime: Date.now()
        });

        // Store token in session for persistence
        if (req.session) {
          (req.session as any).adminToken = sessionToken;
        }

        console.log(`Admin login successful from ${clientIP} at ${new Date().toISOString()}`);
        
        res.json({ 
          success: true, 
          token: sessionToken,
          message: "Admin login successful" 
        });
      } else {
        console.log(`Failed admin login attempt from ${clientIP} at ${new Date().toISOString()}`);
        
        // Add delay to prevent brute force attacks
        await new Promise(resolve => setTimeout(resolve, 1000));
        res.status(401).json({ message: "Invalid credentials" });
      }
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // User registration endpoint with rate limiting
  app.post("/api/auth/register", async (req, res) => {
    try {
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      
      // Check rate limit for registration
      const rateCheck = checkRateLimit(clientIP, registrationAttempts, RATE_LIMITS.REGISTRATION, 'registration');
      if (rateCheck.blocked) {
        res.setHeader('Retry-After', Math.ceil((rateCheck.retryAfter! - Date.now()) / 1000));
        res.setHeader('X-RateLimit-Blocked', 'true');
        return res.status(429).json({ 
          message: rateCheck.message,
          retryAfter: rateCheck.retryAfter,
          type: 'rate_limit_exceeded'
        });
      }

      // Enhanced registration validation schema
      const registrationSchema = z.object({
        username: z.string().min(3).max(30).regex(/^[a-zA-Z0-9_-]+$/, "Username contains invalid characters"),
        email: z.string().email("Invalid email address").max(255),
        password: z.string().min(8).max(100, "Password must be between 8 and 100 characters").regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character"),
        confirmPassword: z.string()
      }).refine((data) => data.password === data.confirmPassword, {
        message: "Passwords don't match",
        path: ["confirmPassword"]
      });

      // Validate input data
      const validation = registrationSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid registration data",
          errors: validation.error.issues 
        });
      }

      const { username, email, password } = validation.data;

      // Set rate limiting headers
      if (rateCheck.remaining !== undefined) {
        res.setHeader('X-RateLimit-Remaining', rateCheck.remaining.toString());
        res.setHeader('X-RateLimit-Limit', RATE_LIMITS.REGISTRATION.maxAttempts.toString());
      }

      // Check if user already exists (would typically check database)
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ message: "Username already exists" });
      }

      // Hash password and create user (implementation would depend on your auth system)
      console.log(`Registration attempt from ${clientIP} for username: ${username}, email: ${email}`);
      
      // For demo purposes, return success without actually creating user
      res.status(201).json({ 
        success: true, 
        message: "Registration successful. Please check your email for verification." 
      });

    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ message: "Registration failed" });
    }
  });

  // Password reset endpoint with rate limiting
  app.post("/api/auth/forgot-password", async (req, res) => {
    try {
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      
      // Check rate limit for password reset
      const rateCheck = checkRateLimit(clientIP, passwordResetAttempts, RATE_LIMITS.PASSWORD_RESET, 'password reset');
      if (rateCheck.blocked) {
        res.setHeader('Retry-After', Math.ceil((rateCheck.retryAfter! - Date.now()) / 1000));
        res.setHeader('X-RateLimit-Blocked', 'true');
        return res.status(429).json({ 
          message: rateCheck.message,
          retryAfter: rateCheck.retryAfter,
          type: 'rate_limit_exceeded'
        });
      }

      // Password reset validation schema
      const passwordResetSchema = z.object({
        email: z.string().email("Invalid email address").max(255)
      });

      // Validate input data
      const validation = passwordResetSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid email address",
          errors: validation.error.issues 
        });
      }

      const { email } = validation.data;

      // Set rate limiting headers
      if (rateCheck.remaining !== undefined) {
        res.setHeader('X-RateLimit-Remaining', rateCheck.remaining.toString());
        res.setHeader('X-RateLimit-Limit', RATE_LIMITS.PASSWORD_RESET.maxAttempts.toString());
      }

      // Log password reset attempt
      console.log(`Password reset attempt from ${clientIP} for email: ${email}`);
      
      // Always return success to prevent email enumeration attacks
      res.json({ 
        success: true, 
        message: "If an account with that email exists, you will receive a password reset link." 
      });

    } catch (error) {
      console.error("Password reset error:", error);
      res.status(500).json({ message: "Password reset failed" });
    }
  });

  app.get("/api/admin/auth-check", async (req, res) => {
    try {
      const adminToken = req.headers['x-admin-token'] as string || (req.session as any)?.adminToken;
      
      if (!adminToken) {
        return res.status(401).json({ message: "Not authenticated" });
      }

      const session = adminSessions.get(adminToken);
      if (!session) {
        return res.status(401).json({ message: "Invalid session" });
      }

      // Check if session is expired
      if (Date.now() - session.loginTime > 24 * 60 * 60 * 1000) {
        adminSessions.delete(adminToken);
        return res.status(401).json({ message: "Session expired" });
      }

      res.json({ 
        authenticated: true, 
        username: session.username 
      });
    } catch (error) {
      console.error("Admin auth check error:", error);
      res.status(500).json({ message: "Auth check failed" });
    }
  });

  app.post("/api/admin/logout", async (req, res) => {
    try {
      const adminToken = req.headers['x-admin-token'] as string || (req.session as any)?.adminToken;
      
      if (adminToken) {
        adminSessions.delete(adminToken);
        if (req.session) {
          delete (req.session as any).adminToken;
        }
      }

      res.json({ 
        success: true, 
        message: "Logged out successfully" 
      });
    } catch (error) {
      console.error("Admin logout error:", error);
      res.status(500).json({ message: "Logout failed" });
    }
  });

  // Admin API endpoints for navigation
  app.get("/api/admin/players", requireAdminAuth, async (req, res) => {
    try {
      const players = await storage.getAllUsers();
      res.json(players);
    } catch (error) {
      console.error("Admin players error:", error);
      res.status(500).json({ message: "Failed to fetch players" });
    }
  });

  app.get("/api/admin/player-stats", requireAdminAuth, async (req, res) => {
    try {
      const players = await storage.getAllUsers();
      const stats = {
        totalPlayers: players.length,
        activeToday: players.filter(p => p.username !== "LOGGED_OUT").length,
        verifiedPlayers: players.filter(p => p.isAdmin === false).length,
        bannedPlayers: 0
      };
      res.json(stats);
    } catch (error) {
      console.error("Admin player stats error:", error);
      res.status(500).json({ message: "Failed to fetch player stats" });
    }
  });

  app.get("/api/admin/boxes", requireAdminAuth, async (req, res) => {
    try {
      const boxes = await storage.getAllBoxes();
      res.json(boxes);
    } catch (error) {
      console.error("Admin boxes error:", error);
      res.status(500).json({ message: "Failed to fetch boxes" });
    }
  });

  app.get("/api/admin/items", requireAdminAuth, async (req, res) => {
    try {
      const items = await storage.getAllItems();
      res.json(items);
    } catch (error) {
      console.error("Admin items error:", error);
      res.status(500).json({ message: "Failed to fetch items" });
    }
  });

  app.get("/api/admin/analytics", requireAdminAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const boxes = await storage.getAllBoxes();
      const items = await storage.getAllItems();
      
      const analytics = {
        totalUsers: users.length,
        totalBoxes: boxes.length,
        totalItems: items.length,
        totalRevenue: users.reduce((sum, user) => sum + parseFloat(user.usdBalance || "0"), 0),
        dailyActiveUsers: users.filter(u => u.username !== "LOGGED_OUT").length,
        conversionRate: "2.5%",
        averageOrderValue: "$45.20"
      };
      res.json(analytics);
    } catch (error) {
      console.error("Admin analytics error:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  // URL validation schema to prevent SSRF attacks
  const urlValidationSchema = z.object({
    url: z.string().url().refine((url) => {
      try {
        const parsedUrl = new URL(url);
        // Only allow HTTPS for security
        if (parsedUrl.protocol !== 'https:') return false;
        
        // Block private/internal networks to prevent SSRF
        const hostname = parsedUrl.hostname.toLowerCase();
        const blockedPatterns = [
          /^localhost$/i,
          /^127\./,
          /^10\./,
          /^172\.(1[6-9]|2[0-9]|3[01])\./,
          /^192\.168\./,
          /^169\.254\./,
          /^::1$/,
          /^fc00:/,
          /^fe80:/,
          /^metadata\.google\.internal$/i,
          /.*\.internal$/i,
          /.*\.local$/i
        ];
        
        return !blockedPatterns.some(pattern => pattern.test(hostname));
      } catch {
        return false;
      }
    }, "Invalid or unsafe URL")
  });

  // Secure image proxy with SSRF protection
  app.get("/api/proxy-image", async (req, res) => {
    try {
      // Validate and sanitize URL input
      const validation = urlValidationSchema.safeParse(req.query);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid URL provided",
          errors: validation.error.issues 
        });
      }

      const { url } = validation.data;

      // Additional security headers
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          'User-Agent': 'RollingDrop-ImageProxy/1.0',
        },
        redirect: 'follow',
        // Note: fetch doesn't support size limit directly, handled by streaming
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        return res.status(404).json({ message: "Image not found" });
      }

      // Validate content type to ensure it's an image
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.startsWith('image/')) {
        return res.status(400).json({ message: "URL does not point to an image" });
      }

      // Set security headers
      res.setHeader('Content-Type', contentType);
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('Cache-Control', 'public, max-age=3600');
      
      const buffer = await response.arrayBuffer();
      res.send(Buffer.from(buffer));
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return res.status(408).json({ message: "Request timeout" });
      }
      console.error("Error proxying image:", error);
      res.status(500).json({ message: "Failed to proxy image" });
    }
  });



  // Authentication check endpoint
  app.get("/api/auth/user", async (req, res) => {
    try {
      // Check for demo authentication first
      if ((req.session as any).demoAuth) {
        const user = await storage.getUser(1);
        if (user) {
          return res.json({
            id: user.id,
            username: user.username,
            usdBalance: user.usdBalance,
            goldCoins: user.goldCoins,
            isAdmin: user.isAdmin
          });
        }
      }

      const user = await storage.getUser(1);
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      res.json({
        id: user.id,
        username: user.username,
        usdBalance: user.usdBalance,
        goldCoins: user.goldCoins,
        isAdmin: user.isAdmin
      });
    } catch (error) {
      res.status(401).json({ message: "Not authenticated" });
    }
  });

  // Get current user (for demo purposes, always return user with ID 1)
  app.get("/api/user", async (req, res) => {
    try {
      const user = await storage.getUser(1);
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      // Return user data even if logged out so frontend can show correct button
      res.json(user);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Get all cases
  app.get("/api/boxes", async (req, res) => {
    try {
      const hostname = req.hostname;
      let boxes;
      
      // Check if this is a whitelabel site request
      const whitelabelSite = await storage.getWhitelabelSiteByDomain(hostname);
      if (whitelabelSite) {
        // Get boxes associated with this whitelabel through the junction table
        boxes = await storage.getWhitelabelBoxes(whitelabelSite.whitelabelId);
      } else {
        // For the main platform, show all boxes
        boxes = await storage.getAllBoxes();
      }
      
      // Add highest rarity information for each box
      const boxesWithRarity = await Promise.all(
        boxes.map(async (box) => {
          try {
            const items = await storage.getItemsByBox(box.id);
            const highestRarity = items.length > 0 
              ? items.reduce((highest, item) => {
                  const rarityValues = { common: 1, rare: 2, epic: 3, legendary: 4, mythical: 5 };
                  const itemRarity = rarityValues[item.rarity.toLowerCase() as keyof typeof rarityValues] || 1;
                  const highestRarity = rarityValues[highest.toLowerCase() as keyof typeof rarityValues] || 1;
                  return itemRarity > highestRarity ? item.rarity : highest;
                }, 'common')
              : 'common';
            
            return {
              ...box,
              highestRarity
            };
          } catch (error) {
            console.error(`Error fetching items for box ${box.id}:`, error);
            return {
              ...box,
              highestRarity: 'common'
            };
          }
        })
      );
      
      res.json(boxesWithRarity);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch boxes" });
    }
  });

  // Get featured boxes
  app.get("/api/boxes/featured", async (req, res) => {
    try {
      const hostname = req.hostname;
      let featuredBoxes;
      
      // Check if this is a whitelabel site request
      const whitelabelSite = await storage.getWhitelabelSiteByDomain(hostname);
      if (whitelabelSite) {
        // Get boxes associated with this whitelabel and filter for featured ones
        const whitelabelBoxes = await storage.getWhitelabelBoxes(whitelabelSite.whitelabelId);
        featuredBoxes = whitelabelBoxes.filter((box: any) => 
          box.whitelabelBox?.featured === true || (box.whitelabelBox?.featured !== false && box.featured === true)
        );
      } else {
        // For the main platform, show all featured boxes
        featuredBoxes = await storage.getFeaturedBoxes();
      }
      
      // Add highest rarity information for each box
      const boxesWithRarity = await Promise.all(
        featuredBoxes.map(async (box) => {
          try {
            const items = await storage.getItemsByBox(box.id);
            const highestRarity = items.length > 0 
              ? items.reduce((highest, item) => {
                  const rarityValues = { common: 1, rare: 2, epic: 3, legendary: 4, mythical: 5 };
                  const itemRarity = rarityValues[item.rarity.toLowerCase() as keyof typeof rarityValues] || 1;
                  const highestRarity = rarityValues[highest.toLowerCase() as keyof typeof rarityValues] || 1;
                  return itemRarity > highestRarity ? item.rarity : highest;
                }, 'common')
              : 'common';
            
            return {
              ...box,
              highestRarity
            };
          } catch (error) {
            console.error(`Error fetching items for box ${box.id}:`, error);
            return {
              ...box,
              highestRarity: 'common'
            };
          }
        })
      );
      
      res.json(boxesWithRarity);
    } catch (error) {
      console.error("Error fetching featured boxes:", error);
      res.status(500).json({ message: "Failed to fetch featured boxes" });
    }
  });

  // Input validation schemas
  const boxIdSchema = z.object({
    id: z.string().regex(/^\d+$/, "Box ID must be a positive integer").transform(Number).refine(n => n > 0 && n <= 2147483647, "Invalid box ID range")
  });

  const boxOpenSchema = z.object({
    boxId: z.number().int().positive().max(2147483647, "Invalid box ID")
  });

  // Get items for a specific box
  app.get("/api/boxes/:id/items", async (req, res) => {
    try {
      // Validate box ID parameter
      const validation = boxIdSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid box ID",
          errors: validation.error.issues 
        });
      }

      const { id: boxId } = validation.data;
      const items = await storage.getItemsByBox(boxId);
      res.json(items);
    } catch (error) {
      console.error("Error fetching box items:", error);
      res.status(500).json({ message: "Failed to fetch box items" });
    }
  });

  // Get box with items
  app.get("/api/boxes/:id", async (req, res) => {
    try {
      // Validate box ID parameter
      const validation = boxIdSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid box ID",
          errors: validation.error.issues 
        });
      }

      const { id: boxId } = validation.data;
      const boxWithItems = await storage.getBoxWithItems(boxId);
      if (!boxWithItems) {
        return res.status(404).json({ message: "Box not found" });
      }

      res.json(boxWithItems);
    } catch (error) {
      console.error("Error fetching box:", error);
      res.status(500).json({ message: "Failed to fetch box" });
    }
  });

  // Open a box
  app.post("/api/boxes/open", async (req, res) => {
    try {
      // Validate input data
      const validation = boxOpenSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid request data",
          errors: validation.error.issues 
        });
      }

      const { boxId } = validation.data;
      const userId = 1; // For demo purposes, always use user ID 1

      // Get box and user
      const boxData = await storage.getBox(boxId);
      const user = await storage.getUser(userId);

      if (!boxData || !user) {
        return res.status(404).json({ message: "Box or user not found" });
      }

      // Check if user has enough balance
      const boxPrice = parseFloat(boxData.price);
      const userBalance = parseFloat(user.usdBalance);
      if (userBalance < boxPrice) {
        return res.status(400).json({ message: "Insufficient balance" });
      }

      // Get box items for probability calculation
      const items = await storage.getItemsByBox(boxId);
      if (items.length === 0) {
        return res.status(400).json({ message: "Box contains no items" });
      }

      // Rarity-based drop chance system
      const rarityWeights = {
        common: 20,
        rare: 15,
        epic: 10,
        legendary: 5,
        mythical: 1
      };

      // Group items by rarity
      const itemsByRarity = items.reduce((groups, item) => {
        const rarity = item.rarity;
        if (!groups[rarity]) groups[rarity] = [];
        groups[rarity].push(item);
        return groups;
      }, {} as Record<string, typeof items>);

      // Calculate total weight based on available rarities
      const availableRarities = Object.keys(itemsByRarity);
      const totalWeight = availableRarities.reduce((sum, rarity) => 
        sum + (rarityWeights[rarity as keyof typeof rarityWeights] || 0), 0
      );

      // Select rarity first
      const rarityRandom = Math.floor(Math.random() * totalWeight);
      let currentWeight = 0;
      let selectedRarity = availableRarities[0];

      for (const rarity of availableRarities) {
        currentWeight += rarityWeights[rarity as keyof typeof rarityWeights] || 0;
        if (rarityRandom < currentWeight) {
          selectedRarity = rarity;
          break;
        }
      }

      // Then randomly select an item from that rarity tier
      const rarityItems = itemsByRarity[selectedRarity];
      const selectedItem = rarityItems[Math.floor(Math.random() * rarityItems.length)];

      // Deduct USD balance from user and award gold coins
      const newUsdBalance = userBalance - boxPrice;
      const goldCoinsAwarded = Math.floor(boxPrice * 10); // Award 10 gold coins per USD spent
      const updatedUser = await storage.updateUser(userId, { 
        usdBalance: newUsdBalance.toFixed(2),
        goldCoins: (user.goldCoins || 0) + goldCoinsAwarded
      });

      // Add item to user's inventory
      await storage.addUserItem({
        userId,
        itemId: selectedItem.id,
        quantity: 1
      });

      // Record the box opening
      await storage.recordBoxOpening({
        userId,
        boxId,
        itemId: selectedItem.id
      });

      // Invalidate recent openings cache to show fresh data
      recentOpeningsCache = null;

      const result: BoxOpeningResult = {
        item: selectedItem,
        user: updatedUser!,
        success: true
      };

      res.json(result);
    } catch (error) {
      console.error("Case opening error:", error);
      res.status(500).json({ message: "Failed to open case" });
    }
  });

  // Open a specific box (alternative route for frontend compatibility)
  app.post("/api/boxes/:id/open", async (req, res) => {
    try {
      const boxId = parseInt(req.params.id);
      const userId = 1; // For demo purposes, always use user ID 1

      if (isNaN(boxId)) {
        return res.status(400).json({ message: "Invalid box ID" });
      }

      // Get box and user
      const boxData = await storage.getBox(boxId);
      const user = await storage.getUser(userId);

      if (!boxData || !user) {
        return res.status(404).json({ message: "Box or user not found" });
      }

      // Check if user has enough balance
      const boxPrice = parseFloat(boxData.price);
      const userBalance = parseFloat(user.usdBalance);
      if (userBalance < boxPrice) {
        return res.status(400).json({ message: "Insufficient balance" });
      }

      // Get box items for probability calculation
      const items = await storage.getItemsByBox(boxId);
      if (items.length === 0) {
        return res.status(400).json({ message: "Box contains no items" });
      }

      // Rarity-based drop chance system
      const rarityWeights = {
        common: 20,
        rare: 15,
        epic: 10,
        legendary: 5,
        mythical: 1
      };

      // Group items by rarity
      const itemsByRarity = items.reduce((groups, item) => {
        const rarity = item.rarity;
        if (!groups[rarity]) groups[rarity] = [];
        groups[rarity].push(item);
        return groups;
      }, {} as Record<string, typeof items>);

      // Calculate total weight based on available rarities
      const availableRarities = Object.keys(itemsByRarity);
      const totalWeight = availableRarities.reduce((sum, rarity) => 
        sum + (rarityWeights[rarity as keyof typeof rarityWeights] || 0), 0
      );

      // Select rarity first
      const rarityRandom = Math.floor(Math.random() * totalWeight);
      let currentWeight = 0;
      let selectedRarity = availableRarities[0];

      for (const rarity of availableRarities) {
        currentWeight += rarityWeights[rarity as keyof typeof rarityWeights] || 0;
        if (rarityRandom < currentWeight) {
          selectedRarity = rarity;
          break;
        }
      }

      // Then select random item from that rarity
      const rarityItems = itemsByRarity[selectedRarity];
      const selectedItem = rarityItems[Math.floor(Math.random() * rarityItems.length)];

      // Add item to user's inventory
      console.log("Adding item to inventory - userId:", userId, "itemId:", selectedItem.id);
      await storage.addUserItem({
        userId: userId,
        itemId: selectedItem.id,
        quantity: 1
      });

      // Deduct box price from user's balance
      const newBalance = (userBalance - boxPrice).toFixed(2);
      const updatedUser = await storage.updateUser(userId, { 
        usdBalance: newBalance 
      });

      // Record the box opening
      await storage.recordBoxOpening({
        userId,
        boxId,
        itemId: selectedItem.id
      });

      // Invalidate recent openings cache to show fresh data
      recentOpeningsCache = null;

      const result: BoxOpeningResult = {
        item: selectedItem,
        user: updatedUser!,
        success: true,
        isPaidOpening: true
      };

      res.json(result);
    } catch (error) {
      console.error("Case opening error:", error);
      res.status(500).json({ message: "Failed to open case" });
    }
  });

  // Additional validation schemas
  const userIdSchema = z.object({
    id: z.string().regex(/^\d+$/, "User ID must be a positive integer").transform(Number).refine(n => n > 0 && n <= 2147483647, "Invalid user ID range")
  });

  const inventoryActionSchema = z.object({
    itemId: z.number().int().positive().max(2147483647, "Invalid item ID"),
    quantity: z.number().int().positive().max(1000, "Quantity must be between 1 and 1000")
  });

  const balanceUpdateSchema = z.object({
    amount: z.number().min(0).max(999999.99, "Invalid amount"),
    operation: z.enum(['add', 'subtract', 'set'], { errorMap: () => ({ message: "Operation must be add, subtract, or set" }) })
  });

  // Demo spin - doesn't deduct balance or record opening
  app.post("/api/boxes/:id/demo", async (req, res) => {
    try {
      // Validate box ID parameter
      const validation = boxIdSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid box ID",
          errors: validation.error.issues 
        });
      }

      const { id: boxId } = validation.data;
      const userId = 1; // For demo purposes, always use user ID 1

      // Get box and user
      const boxData = await storage.getBox(boxId);
      const user = await storage.getUser(userId);

      if (!boxData || !user) {
        return res.status(404).json({ message: "Box or user not found" });
      }

      // Get box items for probability calculation
      const items = await storage.getItemsByBox(boxId);
      if (items.length === 0) {
        return res.status(400).json({ message: "Box contains no items" });
      }

      // Rarity-based drop chance system (same as regular opening)
      const rarityWeights = {
        common: 20,
        rare: 15,
        epic: 10,
        legendary: 5,
        mythical: 1
      };

      // Group items by rarity
      const itemsByRarity = items.reduce((groups, item) => {
        const rarity = item.rarity;
        if (!groups[rarity]) groups[rarity] = [];
        groups[rarity].push(item);
        return groups;
      }, {} as Record<string, typeof items>);

      // Calculate total weight based on available rarities
      const availableRarities = Object.keys(itemsByRarity);
      const totalWeight = availableRarities.reduce((sum, rarity) => 
        sum + (rarityWeights[rarity as keyof typeof rarityWeights] || 0), 0
      );

      // Select rarity first
      const rarityRandom = Math.floor(Math.random() * totalWeight);
      let currentWeight = 0;
      let selectedRarity = availableRarities[0];

      for (const rarity of availableRarities) {
        currentWeight += rarityWeights[rarity as keyof typeof rarityWeights] || 0;
        if (rarityRandom < currentWeight) {
          selectedRarity = rarity;
          break;
        }
      }

      // Then select random item from that rarity
      const rarityItems = itemsByRarity[selectedRarity];
      const selectedItem = rarityItems[Math.floor(Math.random() * rarityItems.length)];

      // Demo spin doesn't add to inventory or deduct balance
      const result: BoxOpeningResult = {
        item: selectedItem,
        user: user,
        success: true,
        isPaidOpening: false
      };

      res.json(result);
    } catch (error) {
      console.error("Demo opening error:", error);
      res.status(500).json({ message: "Failed to demo open case" });
    }
  });

  // Quick sell item after box opening
  app.post("/api/items/:itemId/quick-sell", async (req, res) => {
    try {
      const itemId = parseInt(req.params.itemId);
      const userId = 1; // For demo purposes

      if (isNaN(itemId)) {
        return res.status(400).json({ message: "Invalid item ID" });
      }

      // Get user and verify they own the item
      const user = await storage.getUser(userId);
      const userItems = await storage.getUserItems(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const userItem = userItems.find(ui => ui.item.id === itemId);
      if (!userItem || userItem.quantity < 1) {
        return res.status(400).json({ message: "Item not found in inventory" });
      }

      // Calculate quick sell price (80% of item value)
      const itemValue = parseFloat(userItem.item.value || "0");
      const quickSellPrice = itemValue * 0.8;

      // Remove item from inventory
      await storage.removeUserItem(userId, itemId, 1);

      // Create marketplace listing
      const marketplaceListing = await storage.createMarketListing({
        sellerId: userId,
        itemId: itemId,
        price: quickSellPrice.toFixed(2),
        status: 'active'
      });

      res.json({
        success: true,
        item: userItem.item,
        sellPrice: quickSellPrice,
        listingId: marketplaceListing.id,
        message: "Item listed on marketplace"
      });

    } catch (error) {
      console.error("Quick sell error:", error);
      res.status(500).json({ message: "Failed to quick sell item" });
    }
  });

  // Simple demo login route
  app.get("/api/demo-login-simple", async (req, res) => {
    try {
      // Restore original user data to indicate logged in state
      const result = await storage.updateUser(1, { 
        username: "Player_2024",
        usdBalance: "12529.00" 
      });
      console.log("Demo login successful:", result);
      res.send(`
        <html>
          <head><title>Logging In</title></head>
          <body>
            <script>
              localStorage.clear();
              window.location.href = '/';
            </script>
            <p>Logging in...</p>
          </body>
        </html>
      `);
    } catch (error) {
      console.error("Demo login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // Get user inventory
  app.get("/api/user/inventory", async (req, res) => {
    try {
      const user = await storage.getUser(1);
      if (!user) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      
      const userId = 1; // For demo purposes
      const inventory = await storage.getUserItems(userId);
      res.json(inventory);
    } catch (error) {
      console.error("Inventory error:", error);
      res.status(500).json({ message: "Failed to fetch inventory" });
    }
  });

  // Enhanced user stats endpoint
  app.get("/api/user/stats", async (req, res) => {
    try {
      const userId = 1;
      const stats = await storage.getUserStats(userId);
      const user = await storage.getUser(userId);
      
      // Calculate level and experience based on actual user activity
      const totalExp = (stats?.totalCasesOpened || 0) * 10 + (stats?.rareItemsFound || 0) * 50;
      const level = Math.floor(totalExp / 100) + 1;
      const currentLevelExp = totalExp % 100;
      const expToNext = 100 - currentLevelExp;
      
      res.json({
        totalCasesOpened: stats?.totalCasesOpened || 0,
        totalSpent: stats?.totalSpent || 0,
        rareItemsFound: stats?.rareItemsFound || 0,
        level: level,
        experience: currentLevelExp,
        experienceToNext: expToNext,
        winStreak: 0,
        battlesWon: 0,
        battlesPlayed: 0,
        favoriteBox: "Aquatic Arcana",
        joinDate: user?.createdAt || new Date().toISOString(),
        lastLogin: new Date().toISOString()
      });
    } catch (error) {
      console.error("Error fetching user stats:", error);
      res.status(500).json({ error: "Failed to fetch user stats" });
    }
  });

  // User achievements endpoint
  app.get("/api/user/achievements", async (req, res) => {
    try {
      const userId = 1;
      const achievements = await storage.getUserAchievements(userId);
      res.json(achievements);
    } catch (error) {
      console.error("Error fetching achievements:", error);
      res.status(500).json({ error: "Failed to fetch achievements" });
    }
  });

  // Query parameter validation schemas
  const limitSchema = z.object({
    limit: z.string().optional().transform(val => val ? parseInt(val) : 10).refine(n => n >= 1 && n <= 100, "Limit must be between 1 and 100")
  });

  const timeframeSchema = z.object({
    timeframe: z.enum(['day', 'week', 'month', 'all'], { errorMap: () => ({ message: "Timeframe must be day, week, month, or all" }) }).optional().default('all')
  });

  // Get recent openings with intelligent caching
  app.get("/api/recent-openings", async (req, res) => {
    try {
      const now = Date.now();
      
      // Check if cache is valid
      if (recentOpeningsCache && (now - recentOpeningsCache.timestamp) < CACHE_DURATION) {
        return res.json(recentOpeningsCache.data);
      }

      // Validate query parameters
      const validation = limitSchema.safeParse(req.query);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid query parameters",
          errors: validation.error.issues 
        });
      }

      const { limit } = validation.data;
      const recentOpenings = await storage.getRecentOpenings(limit);
      
      // Update cache
      recentOpeningsCache = {
        data: recentOpenings,
        timestamp: now
      };
      
      res.json(recentOpenings);
    } catch (error) {
      console.error("Recent openings error:", error);
      res.status(500).json({ message: "Failed to fetch recent openings" });
    }
  });

  // Statistics API endpoints
  app.get("/api/statistics/overview", async (req, res) => {
    try {
      const userId = 1;
      
      // Validate timeframe parameter
      const validation = timeframeSchema.safeParse(req.query);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid query parameters",
          errors: validation.error.issues 
        });
      }

      const { timeframe } = validation.data;
      
      // Get user's box openings and calculate statistics
      const openings = await storage.getUserBoxOpenings(userId, timeframe);
      const userItems = await storage.getUserItems(userId);
      const boxes = await storage.getAllBoxes();
      
      let totalSpent = 0;
      let totalValue = 0;
      let casesOpened = 0;
      let bestItem = null;
      let bestItemValue = 0;
      
      // Calculate totals from actual openings
      for (const opening of openings) {
        const box = boxes.find(b => b.id === opening.boxId);
        if (box) {
          totalSpent += parseFloat(box.price);
          casesOpened++;
        }
      }
      
      // Calculate total value from user inventory
      for (const userItem of userItems) {
        const itemValue = parseFloat(userItem.item.value || "0");
        totalValue += itemValue;
        
        if (itemValue > bestItemValue) {
          bestItemValue = itemValue;
          bestItem = userItem.item;
        }
      }
      
      const profit = totalValue - totalSpent;
      const averageValue = userItems.length > 0 ? totalValue / userItems.length : 0;
      const winRate = casesOpened > 0 ? (userItems.length / casesOpened) * 100 : 0;
      
      res.json({
        totalSpent,
        totalValue,
        profit,
        casesOpened,
        itemsWon: userItems.length,
        averageValue,
        winRate,
        bestItem
      });
    } catch (error) {
      console.error("Error fetching statistics overview:", error);
      res.status(500).json({ error: "Failed to fetch statistics overview" });
    }
  });

  app.get("/api/statistics/history", async (req, res) => {
    try {
      const userId = 1;
      const timeframe = req.query.timeframe as string || 'all';
      
      const openings = await storage.getUserBoxOpeningsWithDetails(userId, timeframe);
      
      res.json(openings);
    } catch (error) {
      console.error("Error fetching opening history:", error);
      res.status(500).json({ error: "Failed to fetch opening history" });
    }
  });

  app.get("/api/statistics/drop-rates", async (req, res) => {
    try {
      const userId = 1;
      const timeframe = req.query.timeframe as string || 'all';
      
      const userItems = await storage.getUserItems(userId);
      const rarityStats = new Map();
      
      // Group items by rarity and calculate statistics
      for (const userItem of userItems) {
        const rarity = userItem.item.rarity;
        if (!rarityStats.has(rarity)) {
          rarityStats.set(rarity, {
            rarity,
            count: 0,
            totalValue: 0,
            items: []
          });
        }
        
        const stats = rarityStats.get(rarity);
        stats.count++;
        stats.totalValue += userItem.item.value || 0;
        stats.items.push(userItem.item);
      }
      
      // Convert to array and calculate percentages
      const totalItems = userItems.length;
      const dropRates = Array.from(rarityStats.values()).map(stats => ({
        rarity: stats.rarity,
        count: stats.count,
        percentage: totalItems > 0 ? (stats.count / totalItems) * 100 : 0,
        totalValue: stats.totalValue,
        averageValue: stats.count > 0 ? stats.totalValue / stats.count : 0
      }));
      
      res.json(dropRates);
    } catch (error) {
      console.error("Error fetching drop rates:", error);
      res.status(500).json({ error: "Failed to fetch drop rates" });
    }
  });

  app.get("/api/statistics/timeframe", async (req, res) => {
    try {
      const userId = 1;
      
      // Calculate statistics for different time periods
      const timeframes = ['Today', 'This Week', 'This Month', 'This Year'];
      const stats = [];
      
      for (const period of timeframes) {
        // For demo purposes, we'll use sample data
        // In a real implementation, you'd filter by actual dates
        stats.push({
          period,
          spent: Math.floor(Math.random() * 1000),
          value: Math.floor(Math.random() * 1200),
          profit: Math.floor(Math.random() * 400) - 200,
          cases: Math.floor(Math.random() * 50)
        });
      }
      
      res.json(stats);
    } catch (error) {
      console.error("Error fetching timeframe statistics:", error);
      res.status(500).json({ error: "Failed to fetch timeframe statistics" });
    }
  });

  // Promotional features endpoints
  app.get("/api/promotions/daily-rewards", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const dailyRewards = await storage.getDailyRewards(userId);
      res.json(dailyRewards);
    } catch (error) {
      console.error("Error fetching daily rewards:", error);
      res.status(500).json({ message: "Failed to fetch daily rewards" });
    }
  });

  app.get("/api/promotions/login-streak", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const streak = await storage.getUserLoginStreak(userId);
      const userStats = await storage.getUserStats(userId);
      
      res.json({
        currentStreak: streak,
        longestStreak: userStats?.longestStreak || 0,
        lastLogin: userStats?.lastLoginDate || new Date(),
        nextRewardDay: (streak % 7) + 1
      });
    } catch (error) {
      console.error("Error fetching login streak:", error);
      res.status(500).json({ message: "Failed to fetch login streak" });
    }
  });

  app.get("/api/promotions/referrals", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const referralData = await storage.getUserReferralData(userId);
      res.json(referralData);
    } catch (error) {
      console.error("Error fetching referral data:", error);
      res.status(500).json({ message: "Failed to fetch referral data" });
    }
  });

  app.get("/api/promotions/active", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const promotions = await storage.getActivePromotions(userId);
      res.json(promotions);
    } catch (error) {
      console.error("Error fetching active promotions:", error);
      res.status(500).json({ message: "Failed to fetch active promotions" });
    }
  });

  // Promotional validation schemas
  const dailyRewardSchema = z.object({
    day: z.number().int().min(1).max(7, "Day must be between 1 and 7")
  });

  const referralCodeSchema = z.object({
    code: z.string().min(6).max(20).regex(/^[A-Z0-9]+$/, "Referral code must contain only uppercase letters and numbers")
  });

  app.post("/api/promotions/claim-daily", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Validate input data
      const validation = dailyRewardSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid request data",
          errors: validation.error.issues 
        });
      }

      const { day } = validation.data;
      
      if (!day || day < 1 || day > 7) {
        return res.status(400).json({ message: "Invalid day" });
      }

      const reward = await storage.claimDailyReward(userId, day);
      res.json(reward);
    } catch (error) {
      console.error("Error claiming daily reward:", error);
      res.status(500).json({ message: (error as Error).message || "Failed to claim daily reward" });
    }
  });

  app.post("/api/promotions/redeem-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { code } = req.body;
      
      if (!code || typeof code !== 'string') {
        return res.status(400).json({ message: "Invalid promo code" });
      }

      const result = await storage.redeemPromoCode(userId, code.toUpperCase());
      res.json(result);
    } catch (error) {
      console.error("Error redeeming promo code:", error);
      res.status(500).json({ message: (error as Error).message || "Invalid or expired promo code" });
    }
  });

  app.post("/api/promotions/claim", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { promotionId } = req.body;
      
      if (!promotionId) {
        return res.status(400).json({ message: "Invalid promotion ID" });
      }

      const result = await storage.claimPromotion(userId, promotionId);
      res.json(result);
    } catch (error) {
      console.error("Error claiming promotion:", error);
      res.status(500).json({ message: (error as Error).message || "Failed to claim promotion" });
    }
  });

  // Battle routes
  app.get("/api/battles", async (req, res) => {
    try {
      const battles = await storage.getActiveBattles();
      res.json(battles);
    } catch (error) {
      console.error("Error fetching battles:", error);
      res.status(500).json({ error: "Failed to fetch battles" });
    }
  });

  app.post("/api/battles", async (req, res) => {
    try {
      const { name, boxId, entryFee, maxPlayers, totalRounds } = req.body;
      const userId = 1; // Current user
      
      const battle = await storage.createBattle({
        name: name || "Untitled Battle",
        boxId,
        createdBy: userId,
        entryFee,
        maxPlayers: maxPlayers || 2,
        totalRounds: totalRounds || 3
      });
      
      res.json(battle);
    } catch (error) {
      console.error("Error creating battle:", error);
      res.status(500).json({ error: "Failed to create battle" });
    }
  });

  app.post("/api/battles/:id/join", async (req, res) => {
    try {
      const battleId = parseInt(req.params.id);
      const userId = 1; // Current user
      
      const result = await storage.joinBattle(battleId, userId);
      res.json(result);
    } catch (error) {
      console.error("Error joining battle:", error);
      res.status(500).json({ error: "Failed to join battle" });
    }
  });

  // Landing Banner API routes
  app.get("/api/admin/landing-banner", async (req, res) => {
    try {
      // Return current landing banner configuration
      const config = {
        id: 1,
        title: "OPEN CASES",
        subtitle: "WIN LUXURY ITEMS",
        description: "Open premium cases and win real luxury items including Supreme streetwear, Louis Vuitton accessories, designer watches, and supercars",
        buttonText: "Start Opening Cases",
        items: [
          { id: 1, name: "Lamborghini Urus", image: "https://images.unsplash.com/photo-1544636331-e26879cd4d9b?w=400&h=400&fit=crop&crop=center", position: 0, active: true },
          { id: 2, name: "Rolex Explorer", image: "https://images.unsplash.com/photo-1523170335258-f5ed11844a49?w=400&h=400&fit=crop&crop=center", position: 1, active: true },
          { id: 3, name: "Dior x Jordan 1 Low Grey", image: "https://images.unsplash.com/photo-1549298916-b41d501d3772?w=400&h=400&fit=crop&crop=center", position: 2, active: true },
          { id: 4, name: "Apple Vision Pro", image: "https://images.unsplash.com/photo-1617802690992-15d93263d3a9?w=400&h=400&fit=crop&crop=center", position: 3, active: true },
          { id: 5, name: "Louis Vuitton Sunglasses", image: "https://images.unsplash.com/photo-1511499767150-a48a237f0083?w=400&h=400&fit=crop&crop=center", position: 4, active: true },
          { id: 6, name: "Patek Philippe Nautilus", image: "https://images.unsplash.com/photo-1594534475808-b18fc33b045e?w=400&h=400&fit=crop&crop=center", position: 5, active: true },
          { id: 7, name: "Gucci Mini Jumbo GG Bag", image: "https://images.unsplash.com/photo-1584917865442-de89df76afd3?w=400&h=400&fit=crop&crop=center", position: 6, active: true },
          { id: 8, name: "Gucci Re-Web Sneakers", image: "https://images.unsplash.com/photo-1549298916-b41d501d3772?w=400&h=400&fit=crop&crop=center", position: 7, active: true },
          { id: 9, name: "Supreme x Louis Vuitton Box Logo Tee", image: "https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?w=400&h=400&fit=crop&crop=center", position: 8, active: true }
        ]
      };
      res.json(config);
    } catch (error) {
      console.error("Error fetching landing banner:", error);
      res.status(500).json({ error: "Failed to fetch landing banner" });
    }
  });

  // Admin validation schemas
  const landingBannerSchema = z.object({
    title: z.string().min(1).max(100, "Title must be between 1 and 100 characters").optional(),
    subtitle: z.string().min(1).max(200, "Subtitle must be between 1 and 200 characters").optional(),
    description: z.string().min(1).max(500, "Description must be between 1 and 500 characters").optional(),
    buttonText: z.string().min(1).max(50, "Button text must be between 1 and 50 characters").optional(),
    items: z.array(z.object({
      id: z.number().int().positive(),
      name: z.string().min(1).max(100),
      image: z.string().url("Invalid image URL"),
      position: z.number().int().min(0).max(20),
      active: z.boolean()
    })).max(20, "Maximum 20 items allowed").optional()
  });

  const adminStatsQuerySchema = z.object({
    timeframe: z.enum(['day', 'week', 'month', 'year', 'all']).optional().default('all'),
    includeDetails: z.string().transform(val => val === 'true').optional()
  });

  app.put("/api/admin/landing-banner", requireAdminAuth, async (req, res) => {
    try {
      // Validate input data
      const validation = landingBannerSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid banner configuration",
          errors: validation.error.issues 
        });
      }

      const { title, subtitle, description, buttonText, items } = validation.data;
      
      // Sanitize and update configuration
      const updatedConfig = {
        id: 1,
        title: title || "OPEN CASES",
        subtitle: subtitle || "WIN LUXURY ITEMS", 
        description: description || "Open premium cases and win real luxury items",
        buttonText: buttonText || "Start Opening Cases",
        items: items || []
      };
      
      res.json(updatedConfig);
    } catch (error) {
      console.error("Error updating landing banner:", error);
      res.status(500).json({ error: "Failed to update landing banner" });
    }
  });

  // Admin routes
  app.get("/api/admin/stats", async (req, res) => {
    try {
      const boxes = await storage.getAllBoxes();
      const users = await storage.getAllUsers();
      const items = await storage.getAllItems();
      
      const revenue = boxes.reduce((sum: number, boxItem: any) => {
        return sum + parseFloat(boxItem.price || '0');
      }, 0);

      res.json({
        totalBoxes: boxes.length,
        totalUsers: users.length,
        totalItems: items.length,
        revenue: revenue.toFixed(2)
      });
    } catch (error) {
      console.error("Error fetching admin stats:", error);
      res.status(500).json({ error: "Failed to fetch stats" });
    }
  });



  // Admin Users Management
  app.get("/api/admin/admin-users", requireAdminAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const adminUsers = users.filter(user => user.isAdmin).map(user => ({
        ...user,
        role: user.id === 1 ? 'super_admin' : 'admin',
        lastLogin: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000)
      }));
      res.json(adminUsers);
    } catch (error) {
      console.error("Error fetching admin users:", error);
      res.status(500).json({ error: "Failed to fetch admin users" });
    }
  });

  app.post("/api/admin/admin-users", requireAdminAuth, async (req, res) => {
    try {
      const { username, email, password, role } = req.body;
      const adminUser = await storage.createUser({
        username,
        email,
        usdBalance: "0.00",
        goldCoins: 0,
        isAdmin: true,
        level: 1,
        experience: 0,
        availableRewards: "[]"
      });
      res.json(adminUser);
    } catch (error) {
      console.error("Error creating admin user:", error);
      res.status(500).json({ error: "Failed to create admin user" });
    }
  });

  // Players Management  
  app.get("/api/admin/players", requireAdminAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const players = users.filter(user => !user.isAdmin).map(user => ({
        ...user,
        emailVerified: user.email ? Math.random() > 0.3 : false,
        idVerified: Math.random() > 0.6,
        status: Math.random() > 0.9 ? 'banned' : 'active',
        createdAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000)
      }));
      res.json(players);
    } catch (error) {
      console.error("Error fetching players:", error);
      res.status(500).json({ error: "Failed to fetch players" });
    }
  });

  app.get("/api/admin/player-stats", requireAdminAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const players = users.filter(user => !user.isAdmin);
      const stats = {
        totalPlayers: players.length,
        activeToday: Math.floor(players.length * 0.3),
        verifiedPlayers: Math.floor(players.length * 0.7),
        bannedPlayers: Math.floor(players.length * 0.1)
      };
      res.json(stats);
    } catch (error) {
      console.error("Error fetching player stats:", error);
      res.status(500).json({ error: "Failed to fetch player stats" });
    }
  });

  app.get("/api/admin/items", async (req, res) => {
    try {
      const items = await storage.getAllItems();
      res.json(items);
    } catch (error) {
      console.error("Error fetching items:", error);
      res.status(500).json({ error: "Failed to fetch items" });
    }
  });

  // Box-Product Management API Routes
  app.get("/api/admin/boxes/:boxId/items", requireAdminAuth, async (req, res) => {
    try {
      const boxId = parseInt(req.params.boxId);
      if (isNaN(boxId)) {
        return res.status(400).json({ message: "Invalid box ID" });
      }

      const items = await storage.getItemsByBox(boxId);
      res.json(items);
    } catch (error) {
      console.error("Error fetching box items:", error);
      res.status(500).json({ message: "Failed to fetch box items" });
    }
  });

  // Box management validation schemas
  const addItemToBoxSchema = z.object({
    itemId: z.number().int().positive().max(2147483647, "Invalid item ID"),
    dropChance: z.number().int().min(1).max(10000, "Drop chance must be between 1 and 10000")
  });

  const updateDropChanceSchema = z.object({
    dropChance: z.number().int().min(1).max(10000, "Drop chance must be between 1 and 10000")
  });

  app.post("/api/admin/boxes/:boxId/items", requireAdminAuth, async (req, res) => {
    try {
      // Validate box ID parameter
      const boxIdValidation = boxIdSchema.safeParse(req.params);
      if (!boxIdValidation.success) {
        return res.status(400).json({ 
          message: "Invalid box ID",
          errors: boxIdValidation.error.issues 
        });
      }

      // Validate request body
      const bodyValidation = addItemToBoxSchema.safeParse(req.body);
      if (!bodyValidation.success) {
        return res.status(400).json({ 
          message: "Invalid request data",
          errors: bodyValidation.error.issues 
        });
      }

      const { id: boxId } = boxIdValidation.data;
      const { itemId, dropChance } = bodyValidation.data;

      const result = await storage.addItemToBox(boxId, itemId, dropChance);
      res.json(result);
    } catch (error) {
      console.error("Error adding item to box:", error);
      res.status(500).json({ message: "Failed to add item to box" });
    }
  });

  app.put("/api/admin/boxes/:boxId/items/:itemId", requireAdminAuth, async (req, res) => {
    try {
      const boxId = parseInt(req.params.boxId);
      const itemId = parseInt(req.params.itemId);
      const { dropChance } = req.body;

      if (isNaN(boxId) || isNaN(itemId) || isNaN(dropChance)) {
        return res.status(400).json({ message: "Invalid parameters" });
      }

      if (dropChance < 1 || dropChance > 10000) {
        return res.status(400).json({ message: "Drop chance must be between 1 and 10000" });
      }

      const result = await storage.updateItemDropChance(boxId, itemId, dropChance);
      res.json(result);
    } catch (error) {
      console.error("Error updating item drop chance:", error);
      res.status(500).json({ message: "Failed to update item drop chance" });
    }
  });

  app.delete("/api/admin/boxes/:boxId/items/:itemId", requireAdminAuth, async (req, res) => {
    try {
      const boxId = parseInt(req.params.boxId);
      const itemId = parseInt(req.params.itemId);

      if (isNaN(boxId) || isNaN(itemId)) {
        return res.status(400).json({ message: "Invalid parameters" });
      }

      const result = await storage.removeItemFromBox(boxId, itemId);
      res.json(result);
    } catch (error) {
      console.error("Error removing item from box:", error);
      res.status(500).json({ message: "Failed to remove item from box" });
    }
  });

  // Partner Management API Routes
  app.get('/api/admin/partners', requireAdminAuth, async (req, res) => {
    try {
      const partnersList = await db.select().from(partners).orderBy(desc(partners.createdAt));
      res.json(partnersList);
    } catch (error) {
      console.error("Error fetching partners:", error);
      res.status(500).json({ message: "Failed to fetch partners" });
    }
  });

  // Partner management validation schemas
  const createPartnerSchema = z.object({
    name: z.string().min(2).max(100, "Partner name must be between 2 and 100 characters").regex(/^[a-zA-Z0-9\s\-_]+$/, "Partner name contains invalid characters"),
    email: z.string().email("Invalid email address").max(255),
    website: z.string().url("Invalid website URL").max(500).optional(),
    description: z.string().min(10).max(1000, "Description must be between 10 and 1000 characters").optional(),
    webhookUrl: z.string().url("Invalid webhook URL").max(500).optional(),
    allowedDomains: z.array(z.string().regex(/^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/, "Invalid domain format")).max(20, "Maximum 20 domains allowed").optional(),
    rateLimit: z.number().int().min(100).max(10000, "Rate limit must be between 100 and 10000 requests per hour").optional(),
    permissions: z.array(z.enum(['read_boxes', 'open_boxes', 'read_stats', 'webhook_access'])).max(10).optional()
  });

  const updatePartnerSchema = z.object({
    name: z.string().min(2).max(100).regex(/^[a-zA-Z0-9\s\-_]+$/).optional(),
    email: z.string().email().max(255).optional(),
    website: z.string().url().max(500).optional(),
    description: z.string().min(10).max(1000).optional(),
    webhookUrl: z.string().url().max(500).optional(),
    isActive: z.boolean().optional(),
    rateLimit: z.number().int().min(100).max(10000).optional()
  });

  app.post('/api/admin/partners', requireAdminAuth, async (req, res) => {
    try {
      // Validate input data
      const validation = createPartnerSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid partner data",
          errors: validation.error.issues 
        });
      }

      const { name, email, website, description, webhookUrl } = validation.data;
      
      // Generate cryptographically secure API keys
      const apiKey = crypto.randomBytes(32).toString('hex');
      const secretKey = crypto.randomBytes(40).toString('hex');

      // Create safe slug from name
      const slug = name.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');

      const [partner] = await db.insert(partners).values({
        name,
        slug,
        apiKey,
        apiSecret: secretKey,
        webhookUrl: webhookUrl || null
      }).returning();

      res.json({ 
        success: true, 
        message: "Partner created successfully",
        partner,
        apiKey,
        secretKey 
      });
    } catch (error) {
      console.error("Error creating partner:", error);
      res.status(500).json({ message: "Failed to create partner" });
    }
  });

  app.put('/api/admin/partners/:id', requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, email, website, description, webhookUrl, allowedDomains, rateLimit, permissions, status } = req.body;

      const [updatedPartner] = await db.update(partners)
        .set({
          name,
          webhookUrl: webhookUrl || null,
          updatedAt: new Date()
        })
        .where(eq(partners.id, parseInt(id)))
        .returning();

      if (!updatedPartner) {
        return res.status(404).json({ message: "Partner not found" });
      }

      res.json({ success: true, message: "Partner updated successfully", partner: updatedPartner });
    } catch (error) {
      console.error("Error updating partner:", error);
      res.status(500).json({ message: "Failed to update partner" });
    }
  });

  app.delete('/api/admin/partners/:id', requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const partnerId = parseInt(id);

      // First delete related records to avoid foreign key constraint violations
      await db
        .delete(apiUsage)
        .where(eq(apiUsage.partnerId, partnerId));
      
      // Note: partner_transactions table exists but not in schema yet
      await db.execute(sql`DELETE FROM partner_transactions WHERE partner_id = ${partnerId}`);

      // Then delete the partner
      const [deletedPartner] = await db.delete(partners)
        .where(eq(partners.id, partnerId))
        .returning();

      if (!deletedPartner) {
        return res.status(404).json({ message: "Partner not found" });
      }

      res.json({ success: true, message: "Partner deleted successfully" });
    } catch (error) {
      console.error("Error deleting partner:", error);
      res.status(500).json({ message: "Failed to delete partner" });
    }
  });

  // API Usage Logs
  app.get('/api/admin/api-usage', requireAdminAuth, async (req, res) => {
    try {
      const usage = await db
        .select()
        .from(apiUsage)
        .orderBy(desc(apiUsage.timestamp))
        .limit(100);
      
      res.json(usage);
    } catch (error) {
      console.error("Error fetching API usage:", error);
      res.status(500).json({ message: "Failed to fetch API usage" });
    }
  });

  // Partner Transactions
  app.get('/api/admin/partner-transactions', requireAdminAuth, async (req, res) => {
    try {
      const transactions = await db.execute(sql`
        SELECT * FROM partner_transactions 
        ORDER BY created_at DESC 
        LIMIT 100
      `);
      
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching partner transactions:", error);
      res.status(500).json({ message: "Failed to fetch partner transactions" });
    }
  });

  // Partner Box Assignments
  app.get('/api/admin/partner-box-assignments/:partnerId', requireAdminAuth, async (req, res) => {
    try {
      const { partnerId } = req.params;
      
      const assignments = await db
        .select()
        .from(partnerBoxes)
        .where(eq(partnerBoxes.partnerId, parseInt(partnerId)));
      
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching partner box assignments:", error);
      res.status(500).json({ message: "Failed to fetch partner box assignments" });
    }
  });

  // Partner box assignment validation schemas
  const partnerBoxAssignmentSchema = z.object({
    partnerId: z.number().int().positive().max(2147483647, "Invalid partner ID"),
    boxIds: z.array(z.number().int().positive().max(2147483647)).max(100, "Maximum 100 boxes allowed").optional(),
    hasAllBoxes: z.boolean().optional()
  });

  const partnerIdParamSchema = z.object({
    partnerId: z.string().regex(/^\d+$/, "Partner ID must be a positive integer").transform(Number).refine(n => n > 0 && n <= 2147483647, "Invalid partner ID range")
  });

  app.get('/api/admin/partner-box-assignments/:partnerId', requireAdminAuth, async (req, res) => {
    try {
      // Validate partner ID parameter
      const validation = partnerIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid partner ID",
          errors: validation.error.issues 
        });
      }

      const { partnerId } = validation.data;
      
      const assignments = await db
        .select()
        .from(partnerBoxes)
        .where(eq(partnerBoxes.partnerId, partnerId));
      
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching partner box assignments:", error);
      res.status(500).json({ message: "Failed to fetch partner box assignments" });
    }
  });

  app.post('/api/admin/partner-box-assignments', requireAdminAuth, async (req, res) => {
    try {
      // Validate input data
      const validation = partnerBoxAssignmentSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid assignment data",
          errors: validation.error.issues 
        });
      }

      const { partnerId, boxIds, hasAllBoxes } = validation.data;
      
      // First delete existing assignments for this partner
      await db
        .delete(partnerBoxes)
        .where(eq(partnerBoxes.partnerId, partnerId));
      
      if (hasAllBoxes) {
        // If partner has access to all boxes, create a single record with hasAllBoxes = true
        const [assignment] = await db
          .insert(partnerBoxes)
          .values({
            partnerId: partnerId,
            boxId: 1 // Default box for all-access
          })
          .returning();
        
        res.json({ success: true, assignment });
      } else if (boxIds && boxIds.length > 0) {
        // Create individual assignments for each box
        const assignments = await db
          .insert(partnerBoxes)
          .values(
            boxIds.map((boxId: number) => ({
              partnerId,
              boxId
            }))
          )
          .returning();
        
        res.json({ success: true, assignments });
      } else {
        res.json({ success: true, message: "No box assignments created" });
      }
    } catch (error) {
      console.error("Error creating partner box assignments:", error);
      res.status(500).json({ message: "Failed to create partner box assignments" });
    }
  });

  app.post("/api/admin/boxes", async (req, res) => {
    try {
      const result = insertBoxSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ error: "Invalid box data", details: result.error.issues });
      }
      
      const newBox = await storage.createBox(result.data);
      res.status(201).json(newBox);
    } catch (error) {
      console.error("Error creating box:", error);
      res.status(500).json({ error: "Failed to create box" });
    }
  });

  app.post("/api/admin/boxes", async (req, res) => {
    try {
      console.log("Creating box with data:", req.body);
      const result = insertBoxSchema.safeParse(req.body);
      if (!result.success) {
        console.log("Validation failed:", result.error.issues);
        return res.status(400).json({ error: "Invalid box data", details: result.error.issues });
      }
      
      const newBox = await storage.createBox(result.data);
      res.status(201).json(newBox);
    } catch (error) {
      console.error("Error creating box:", error);
      res.status(500).json({ error: "Failed to create box" });
    }
  });

  app.put("/api/admin/boxes/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log("Updating box with data:", req.body);
      const result = insertBoxSchema.safeParse(req.body);
      if (!result.success) {
        console.log("Validation failed:", result.error.issues);
        return res.status(400).json({ error: "Invalid box data", details: result.error.issues });
      }
      
      const updatedBox = await storage.updateBox(id, result.data);
      if (!updatedBox) {
        return res.status(404).json({ error: "Box not found" });
      }
      res.json(updatedBox);
    } catch (error) {
      console.error("Error updating box:", error);
      res.status(500).json({ error: "Failed to update box" });
    }
  });

  app.delete("/api/admin/boxes/:id", requireAdminAuth, async (req, res) => {
    try {
      // Validate box ID parameter
      const validation = boxIdSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid box ID",
          errors: validation.error.issues 
        });
      }

      const { id } = validation.data;
      const success = await storage.deleteBox(id);
      if (!success) {
        return res.status(404).json({ error: "Box not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting case:", error);
      res.status(500).json({ error: "Failed to delete case" });
    }
  });

  app.post("/api/admin/items", async (req, res) => {
    try {
      const result = insertItemSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ error: "Invalid item data", details: result.error.issues });
      }
      
      const newItem = await storage.createItem(result.data);
      res.status(201).json(newItem);
    } catch (error) {
      console.error("Error creating item:", error);
      res.status(500).json({ error: "Failed to create item" });
    }
  });

  app.put("/api/admin/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const result = insertItemSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ error: "Invalid item data", details: result.error.issues });
      }
      
      const updatedItem = await storage.updateItem(id, result.data);
      if (!updatedItem) {
        return res.status(404).json({ error: "Item not found" });
      }
      res.json(updatedItem);
    } catch (error) {
      console.error("Error updating item:", error);
      res.status(500).json({ error: "Failed to update item" });
    }
  });

  app.delete("/api/admin/items/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteItem(id);
      if (!success) {
        return res.status(404).json({ error: "Item not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting item:", error);
      res.status(500).json({ error: "Failed to delete item" });
    }
  });

  // Achievement routes
  app.get("/api/achievements", async (req, res) => {
    try {
      const achievements = await storage.getAllAchievements();
      res.json(achievements);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch achievements" });
    }
  });

  app.get("/api/user/achievements", async (req, res) => {
    try {
      const userId = 1; // For demo purposes
      const achievements = await storage.getUserAchievements(userId);
      res.json(achievements);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch user achievements" });
    }
  });

  // Achievement validation schemas
  const achievementIdSchema = z.object({
    id: z.string().regex(/^\d+$/, "Achievement ID must be a positive integer").transform(Number).refine(n => n > 0 && n <= 2147483647, "Invalid achievement ID range")
  });

  app.post("/api/achievements/:id/claim", async (req, res) => {
    try {
      const userId = 1; // For demo purposes
      
      // Validate achievement ID parameter
      const validation = achievementIdSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({ 
          message: "Invalid achievement ID",
          errors: validation.error.issues 
        });
      }

      const { id: achievementId } = validation.data;
      const reward = await storage.claimAchievementReward(userId, achievementId);
      res.json(reward);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to claim achievement reward" });
    }
  });

  // Admin Achievements Management
  app.get("/api/admin/achievements", requireAdminAuth, async (req, res) => {
    try {
      const achievements = await storage.getAllAchievements();
      res.json(achievements);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch achievements" });
    }
  });

  app.get("/api/admin/achievement-stats", requireAdminAuth, async (req, res) => {
    try {
      const stats = {
        totalAchievements: 15,
        completedToday: 42,
        activeUsers: 156,
        completionRate: 68
      };
      res.json(stats);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch achievement stats" });
    }
  });

  app.post("/api/admin/achievements", requireAdminAuth, async (req, res) => {
    try {
      const achievementData = req.body;
      const achievement = await storage.createAchievement(achievementData);
      res.json(achievement);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to create achievement" });
    }
  });

  app.put("/api/admin/achievements/:id", requireAdminAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const achievementData = req.body;
      const achievement = await storage.updateAchievement(id, achievementData);
      res.json(achievement);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to update achievement" });
    }
  });

  app.delete("/api/admin/achievements/:id", requireAdminAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteAchievement(id);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ message: "Failed to delete achievement" });
    }
  });

  app.post("/api/admin/achievements/reset-progress", requireAdminAuth, async (req, res) => {
    try {
      const { achievementId, userId } = req.body;
      await storage.resetAchievementProgress(achievementId, userId);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ message: "Failed to reset achievement progress" });
    }
  });

  // Admin Promotions Management
  app.get("/api/admin/daily-rewards", requireAdminAuth, async (req, res) => {
    try {
      const dailyRewards = [
        { id: 1, day: 1, coins: 100, gems: 0, active: true },
        { id: 2, day: 2, coins: 150, gems: 0, active: true },
        { id: 3, day: 3, coins: 200, gems: 5, active: true },
        { id: 4, day: 4, coins: 250, gems: 0, active: true },
        { id: 5, day: 5, coins: 300, gems: 10, active: true },
        { id: 6, day: 6, coins: 400, gems: 0, active: true },
        { id: 7, day: 7, coins: 500, gems: 25, bonus: "Weekly Bonus!", active: true }
      ];
      res.json(dailyRewards);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch daily rewards" });
    }
  });

  app.get("/api/admin/promo-codes", requireAdminAuth, async (req, res) => {
    try {
      const promoCodes = [
        {
          id: 1,
          code: "WELCOME100",
          type: "coins",
          value: 100,
          maxUses: 1000,
          currentUses: 245,
          expiresAt: "2024-12-31T23:59:59Z",
          active: true,
          description: "Welcome bonus for new users"
        },
        {
          id: 2,
          code: "GEMS50",
          type: "gems",
          value: 50,
          maxUses: 500,
          currentUses: 89,
          expiresAt: "2024-08-31T23:59:59Z",
          active: true,
          description: "Free gems for all users"
        }
      ];
      res.json(promoCodes);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch promo codes" });
    }
  });

  app.get("/api/admin/special-events", requireAdminAuth, async (req, res) => {
    try {
      const specialEvents = [
        {
          id: 1,
          name: "Summer Festival",
          description: "Double rewards on all box openings",
          startDate: "2024-06-01T00:00:00Z",
          endDate: "2024-06-30T23:59:59Z",
          rewards: { multiplier: 2 },
          active: true,
          eventType: "double_rewards"
        },
        {
          id: 2,
          name: "Bonus Weekend",
          description: "Extra coins for weekend players",
          startDate: "2024-06-15T00:00:00Z",
          endDate: "2024-06-16T23:59:59Z",
          rewards: { bonusCoins: 500 },
          active: false,
          eventType: "bonus_coins"
        }
      ];
      res.json(specialEvents);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch special events" });
    }
  });

  app.get("/api/admin/referral-settings", requireAdminAuth, async (req, res) => {
    try {
      const settings = {
        referrerCoins: 500,
        refereeCoins: 250,
        minLevel: 5,
        maxReferrals: 50
      };
      res.json(settings);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch referral settings" });
    }
  });

  app.put("/api/admin/referral-settings", requireAdminAuth, async (req, res) => {
    try {
      const settings = req.body;
      // Update referral settings in storage
      res.json({ success: true, settings });
    } catch (error: any) {
      res.status(500).json({ message: "Failed to update referral settings" });
    }
  });

  // Shipping routes
  app.get("/api/shipping/addresses", async (req, res) => {
    try {
      // For demo purposes, use hardcoded user ID 1
      const userId = 1;
      const addresses = await storage.getUserShippingAddresses(userId);
      res.json(addresses);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch shipping addresses" });
    }
  });

  app.post("/api/shipping/addresses", async (req, res) => {
    try {
      // For demo purposes, use hardcoded user ID 1
      const userId = 1;
      const addressData = {
        ...req.body,
        userId: userId
      };
      const address = await storage.createShippingAddress(addressData);
      res.json(address);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to create shipping address" });
    }
  });

  app.put("/api/shipping/addresses/:id", async (req, res) => {
    try {
      const addressId = parseInt(req.params.id);
      const updates = req.body;
      const address = await storage.updateShippingAddress(addressId, updates);
      if (!address) {
        return res.status(404).json({ message: "Address not found" });
      }
      res.json(address);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to update shipping address" });
    }
  });

  app.delete("/api/shipping/addresses/:id", async (req, res) => {
    try {
      const addressId = parseInt(req.params.id);
      const success = await storage.deleteShippingAddress(addressId);
      if (!success) {
        return res.status(404).json({ message: "Address not found" });
      }
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ message: "Failed to delete shipping address" });
    }
  });

  app.post("/api/shipping/orders", async (req, res) => {
    try {
      // For demo purposes, use hardcoded user ID 1
      const userId = 1;
      const { userItemId, shippingAddressId } = req.body;
      
      // Create shipment order
      const orderData = {
        userId: userId,
        userItemId,
        shippingAddressId,
        status: 'pending' as const,
        shippingCost: "15.99" // Standard shipping cost
      };
      
      const order = await storage.createShipmentOrder(orderData);
      res.json(order);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to create shipment order" });
    }
  });

  app.get("/api/shipping/orders", async (req, res) => {
    try {
      // For demo purposes, use hardcoded user ID 1
      const userId = 1;
      const orders = await storage.getUserShipmentOrders(userId);
      res.json(orders);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch shipment orders" });
    }
  });

  app.put("/api/shipping/orders/:id/status", async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { status, trackingNumber, carrier } = req.body;
      
      const order = await storage.updateShipmentStatus(orderId, status, trackingNumber, carrier);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      res.json(order);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to update shipment status" });
    }
  });

  // Admin shipping order management
  app.get("/api/admin/shipping/orders", requireAdminAuth, async (req, res) => {
    try {
      const orders = await storage.getAllShipmentOrders();
      res.json(orders);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch shipping orders" });
    }
  });

  app.put("/api/admin/shipping/orders/:id", requireAdminAuth, async (req, res) => {
    try {
      const orderId = parseInt(req.params.id);
      const { status, trackingNumber, carrier, notes } = req.body;
      
      const order = await storage.updateShipmentStatus(orderId, status, trackingNumber, carrier, notes);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      res.json(order);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to update shipment order" });
    }
  });

  // Leaderboard routes
  app.get("/api/leaderboard/:type", async (req, res) => {
    try {
      const type = req.params.type as 'cases' | 'spending' | 'rare_items';
      const limit = parseInt(req.query.limit as string) || 10;
      const leaderboard = await storage.getLeaderboard(type, limit);
      res.json(leaderboard);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch leaderboard" });
    }
  });

  // Payment endpoints
  app.post("/api/payments/deposit", async (req, res) => {
    try {
      const { amount, method } = req.body;
      
      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum deposit amount is $5" });
      }

      const userId = 1; // Demo user
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const newBalance = parseFloat(user.usdBalance) + amount;
      await storage.updateUser(userId, { 
        usdBalance: newBalance.toFixed(2) 
      });

      // Record transaction
      await storage.recordTransaction({
        userId,
        type: 'deposit',
        amount: amount.toFixed(2),
        method,
        status: 'completed',
        description: `Deposit via ${method}`
      });

      res.json({ 
        success: true, 
        message: "Deposit successful",
        newBalance: newBalance.toFixed(2)
      });
    } catch (error) {
      console.error("Error processing deposit:", error);
      res.status(500).json({ error: "Failed to process deposit" });
    }
  });

  app.post("/api/payments/withdraw", async (req, res) => {
    try {
      const { amount, method } = req.body;
      
      if (!amount || amount < 10) {
        return res.status(400).json({ error: "Minimum withdrawal amount is $10" });
      }

      const userId = 1; // Demo user
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const currentBalance = parseFloat(user.usdBalance);
      if (amount > currentBalance) {
        return res.status(400).json({ error: "Insufficient balance" });
      }

      const newBalance = currentBalance - amount;
      await storage.updateUser(userId, { 
        usdBalance: newBalance.toFixed(2) 
      });

      res.json({ 
        success: true, 
        message: "Withdrawal initiated",
        newBalance: newBalance.toFixed(2)
      });
    } catch (error) {
      console.error("Error processing withdrawal:", error);
      res.status(500).json({ error: "Failed to process withdrawal" });
    }
  });

  app.post("/api/payments/create-payment-intent", async (req, res) => {
    try {
      const { amount } = req.body;
      
      // For sandbox demo, return mock payment intent
      res.json({
        clientSecret: "pi_demo_client_secret_" + Date.now(),
        amount: amount * 100, // Convert to cents
        currency: "usd"
      });
    } catch (error) {
      console.error("Error creating payment intent:", error);
      res.status(500).json({ error: "Failed to create payment intent" });
    }
  });

  // Advanced Analytics endpoints
  app.get("/api/admin/analytics", requireAdminAuth, async (req, res) => {
    try {
      const totalBoxesOpened = await storage.getTotalBoxesOpened();
      const totalRevenue = await storage.getTotalRevenue();
      const totalUsers = await storage.getTotalUsers();
      const partners = await storage.getAllPartners();
      
      // Calculate analytics metrics
      const analytics = {
        totalRevenue: totalRevenue || 0,
        revenueChange: 12.5,
        activeUsers: totalUsers || 0,
        userGrowth: 8.3,
        totalBoxesOpened: totalBoxesOpened || 0,
        boxOpeningGrowth: 15.2,
        conversionRate: 3.8,
        conversionChange: 2.1,
        dailyActiveUsers: Math.floor((totalUsers || 0) * 0.6),
        avgSessionDuration: 24,
        retentionRate: 78.5,
        churnRate: 4.2,
        totalPartners: partners.length,
        activePartners: partners.filter((p: any) => p.status === 'active').length,
        apiCalls24h: 15847,
        partnerRevenue: Math.floor((totalRevenue || 0) * 0.3),
        boxCategories: [
          { name: 'Tech', value: 35 },
          { name: 'Fashion', value: 25 },
          { name: 'Gaming', value: 20 },
          { name: 'Sports', value: 15 },
          { name: 'Other', value: 5 }
        ],
        recentActivity: [
          { description: 'New partner integration completed', timestamp: '2 hours ago' },
          { description: 'Box opening rate increased by 15%', timestamp: '4 hours ago' },
          { description: 'Premium subscription activated', timestamp: '6 hours ago' },
          { description: 'API usage spike detected', timestamp: '8 hours ago' },
          { description: 'New whitelabel site launched', timestamp: '12 hours ago' }
        ]
      };
      
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  app.get("/api/admin/analytics/revenue", requireAdminAuth, async (req, res) => {
    try {
      const revenueData = [];
      const currentDate = new Date();
      
      for (let i = 29; i >= 0; i--) {
        const date = new Date(currentDate);
        date.setDate(date.getDate() - i);
        
        revenueData.push({
          date: date.toISOString().split('T')[0],
          revenue: Math.floor(Math.random() * 5000) + 2000,
          profit: Math.floor(Math.random() * 2000) + 1000
        });
      }
      
      res.json(revenueData);
    } catch (error) {
      console.error("Error fetching revenue data:", error);
      res.status(500).json({ message: "Failed to fetch revenue data" });
    }
  });

  app.get("/api/admin/analytics/user-growth", requireAdminAuth, async (req, res) => {
    try {
      const userGrowthData = [];
      const currentDate = new Date();
      
      for (let i = 29; i >= 0; i--) {
        const date = new Date(currentDate);
        date.setDate(date.getDate() - i);
        
        userGrowthData.push({
          date: date.toISOString().split('T')[0],
          newUsers: Math.floor(Math.random() * 50) + 10,
          activeUsers: Math.floor(Math.random() * 200) + 100
        });
      }
      
      res.json(userGrowthData);
    } catch (error) {
      console.error("Error fetching user growth data:", error);
      res.status(500).json({ message: "Failed to fetch user growth data" });
    }
  });

  app.get("/api/admin/analytics/box-performance", requireAdminAuth, async (req, res) => {
    try {
      const boxes = await storage.getAllBoxes();
      const boxPerformance = boxes.map((box: any) => ({
        name: box.name,
        opened: Math.floor(Math.random() * 1000) + 100,
        revenue: Math.floor(Math.random() * 10000) + 1000
      })).sort((a: any, b: any) => b.opened - a.opened);
      
      res.json(boxPerformance);
    } catch (error) {
      console.error("Error fetching box performance data:", error);
      res.status(500).json({ message: "Failed to fetch box performance data" });
    }
  });

  app.get("/api/admin/analytics/partner-stats", requireAdminAuth, async (req, res) => {
    try {
      const partners = await storage.getAllPartners();
      const partnerStats = partners.map((partner: any) => ({
        id: partner.id,
        name: partner.name,
        revenue: Math.floor(Math.random() * 50000) + 10000,
        apiCalls: Math.floor(Math.random() * 10000) + 1000
      })).sort((a: any, b: any) => b.revenue - a.revenue);
      
      res.json(partnerStats);
    } catch (error) {
      console.error("Error fetching partner stats:", error);
      res.status(500).json({ message: "Failed to fetch partner stats" });
    }
  });

  // Webhook management endpoints
  app.get("/api/admin/webhooks", requireAdminAuth, async (req, res) => {
    try {
      const webhooks = [
        {
          id: 1,
          partnerId: 10,
          url: "https://api.example.com/webhook",
          events: ["box.opened", "user.registered"],
          active: true,
          lastTriggered: "2024-06-12 10:30:00",
          secret: "webhook_secret_123"
        },
        {
          id: 2,
          partnerId: 11,
          url: "https://partner.site.com/notifications",
          events: ["payment.completed", "item.won"],
          active: true,
          lastTriggered: "2024-06-12 09:15:00",
          secret: "wh_secret_456"
        }
      ];
      res.json(webhooks);
    } catch (error) {
      console.error("Error fetching webhooks:", error);
      res.status(500).json({ message: "Failed to fetch webhooks" });
    }
  });

  app.post("/api/admin/webhooks", requireAdminAuth, async (req, res) => {
    try {
      const { partnerId, url, events, secret, active } = req.body;
      
      const webhook = {
        id: Date.now(),
        partnerId,
        url,
        events,
        secret,
        active: active || true,
        createdAt: new Date().toISOString(),
        lastTriggered: null
      };

      res.json(webhook);
    } catch (error) {
      console.error("Error creating webhook:", error);
      res.status(500).json({ message: "Failed to create webhook" });
    }
  });

  app.put("/api/admin/webhooks/:id", requireAdminAuth, async (req, res) => {
    try {
      const webhookId = parseInt(req.params.id);
      const updates = req.body;
      
      const webhook = {
        id: webhookId,
        ...updates,
        updatedAt: new Date().toISOString()
      };

      res.json(webhook);
    } catch (error) {
      console.error("Error updating webhook:", error);
      res.status(500).json({ message: "Failed to update webhook" });
    }
  });

  app.delete("/api/admin/webhooks/:id", requireAdminAuth, async (req, res) => {
    try {
      const webhookId = parseInt(req.params.id);
      res.json({ success: true, message: "Webhook deleted successfully" });
    } catch (error) {
      console.error("Error deleting webhook:", error);
      res.status(500).json({ message: "Failed to delete webhook" });
    }
  });

  app.post("/api/admin/webhooks/:id/test", requireAdminAuth, async (req, res) => {
    try {
      const webhookId = parseInt(req.params.id);
      
      // Simulate webhook test
      const testResult = {
        id: Date.now(),
        webhookId,
        status: "success",
        statusCode: 200,
        response: "OK",
        duration: Math.floor(Math.random() * 500) + 100,
        timestamp: new Date().toISOString()
      };

      res.json(testResult);
    } catch (error) {
      console.error("Error testing webhook:", error);
      res.status(500).json({ message: "Failed to test webhook" });
    }
  });

  app.get("/api/admin/webhook-logs", requireAdminAuth, async (req, res) => {
    try {
      const logs = [
        {
          id: 1,
          webhookUrl: "https://api.example.com/webhook",
          eventType: "box.opened",
          status: "success",
          statusCode: 200,
          response: "OK",
          duration: 245,
          timestamp: new Date(Date.now() - 1000 * 60 * 15).toISOString()
        },
        {
          id: 2,
          webhookUrl: "https://partner.site.com/notifications",
          eventType: "payment.completed",
          status: "failed",
          statusCode: 500,
          response: "Internal Server Error",
          duration: 1200,
          timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString()
        },
        {
          id: 3,
          webhookUrl: "https://api.example.com/webhook",
          eventType: "user.registered",
          status: "success",
          statusCode: 200,
          response: "User created",
          duration: 180,
          timestamp: new Date(Date.now() - 1000 * 60 * 45).toISOString()
        }
      ];
      res.json(logs);
    } catch (error) {
      console.error("Error fetching webhook logs:", error);
      res.status(500).json({ message: "Failed to fetch webhook logs" });
    }
  });

  // Batch operations endpoints
  app.post("/api/admin/batch/boxes", requireAdminAuth, async (req, res) => {
    try {
      const { operation, boxIds, data } = req.body;
      
      switch (operation) {
        case "delete":
          for (const id of boxIds) {
            await storage.deleteBox(id);
          }
          break;
        case "update":
          for (const id of boxIds) {
            await storage.updateBox(id, data);
          }
          break;
        case "toggle_featured":
          for (const id of boxIds) {
            const box = await storage.getBox(id);
            if (box) {
              await storage.updateBox(id, { featured: !box.featured });
            }
          }
          break;
      }

      res.json({ 
        success: true, 
        message: `Batch ${operation} completed for ${boxIds.length} boxes`,
        affectedCount: boxIds.length
      });
    } catch (error) {
      console.error("Error performing batch operation:", error);
      res.status(500).json({ message: "Failed to perform batch operation" });
    }
  });

  app.post("/api/admin/batch/items", requireAdminAuth, async (req, res) => {
    try {
      const { operation, itemIds, data } = req.body;
      
      switch (operation) {
        case "delete":
          for (const id of itemIds) {
            await storage.deleteItem(id);
          }
          break;
        case "update_rarity":
          for (const id of itemIds) {
            await storage.updateItem(id, { rarity: data.rarity });
          }
          break;
        case "move_to_box":
          for (const id of itemIds) {
            await storage.updateItem(id, { caseId: data.boxId });
          }
          break;
      }

      res.json({ 
        success: true, 
        message: `Batch ${operation} completed for ${itemIds.length} items`,
        affectedCount: itemIds.length
      });
    } catch (error) {
      console.error("Error performing batch operation:", error);
      res.status(500).json({ message: "Failed to perform batch operation" });
    }
  });

  // Daily rewards routes
  app.get("/api/daily-rewards", async (req, res) => {
    try {
      const rewards = storage.getDailyRewards();
      res.json(rewards);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch daily rewards" });
    }
  });

  app.post("/api/daily-rewards/claim/:day", async (req, res) => {
    try {
      const userId = 1; // For demo purposes
      const day = parseInt(req.params.day);
      const reward = await storage.claimDailyReward(userId, day);
      res.json(reward);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to claim daily reward" });
    }
  });

  app.get("/api/user/stats", async (req, res) => {
    try {
      const userId = 1; // For demo purposes
      const stats = await storage.getUserStats(userId);
      res.json(stats);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch user stats" });
    }
  });

  // Transaction history endpoint
  app.get("/api/user/transactions", async (req, res) => {
    try {
      const userId = 1; // Demo user
      const transactions = await storage.getUserTransactions(userId);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching transactions:", error);
      res.status(500).json({ error: "Failed to fetch transactions" });
    }
  });

  // Market endpoints
  app.get("/api/market/items", async (req, res) => {
    try {
      const { search, rarity, sort } = req.query;
      const filters = { search, rarity, sort };
      const marketItems = await storage.getMarketListings(filters);
      res.json(marketItems);
    } catch (error) {
      console.error("Error fetching market items:", error);
      res.status(500).json({ error: "Failed to fetch market items" });
    }
  });

  app.post("/api/market/list", async (req, res) => {
    try {
      const { itemId, price } = req.body;
      const userId = 1; // Demo user

      if (!itemId || !price || price < 0.01) {
        return res.status(400).json({ error: "Invalid item or price" });
      }

      const listing = await storage.createMarketListing({
        itemId,
        price,
        sellerId: userId
      });

      res.json({ 
        success: true, 
        message: "Item listed successfully",
        listing 
      });
    } catch (error: any) {
      console.error("Error creating listing:", error);
      res.status(500).json({ error: error.message || "Failed to create listing" });
    }
  });

  // Quick sell endpoint
  app.post("/api/market/quick-sell", async (req, res) => {
    try {
      const { userItemId } = req.body;
      const userId = 1; // Demo user

      // Get the user item with details
      const userInventory = await storage.getUserItems(userId);
      const userItem = userInventory.find((inv: any) => inv.id === userItemId);
      
      if (!userItem) {
        return res.status(404).json({ message: "Item not found in inventory" });
      }

      // Calculate quick sell price (80% of estimated value)
      const estimatedValue = 100; // Base value for demo
      const quickSellPrice = estimatedValue * 0.8;

      // Create marketplace listing
      const listing = await storage.createMarketListing({
        sellerId: userId,
        itemId: userItem.itemId,
        price: quickSellPrice.toFixed(2),
        status: 'active'
      });

      // Remove item from user's inventory
      await storage.removeUserItem(userId, userItem.itemId, 1);

      res.json({
        success: true,
        item: userItem.item,
        sellPrice: quickSellPrice,
        listingId: listing.id,
        message: "Item listed on marketplace"
      });

    } catch (error) {
      console.error("Quick sell error:", error);
      res.status(500).json({ message: "Failed to quick sell item" });
    }
  });

  app.post("/api/market/buy/:listingId", async (req, res) => {
    try {
      const listingId = parseInt(req.params.listingId);
      const userId = 1; // Demo user

      const result = await storage.buyMarketItem(listingId, userId);
      
      res.json({ 
        success: true, 
        message: "Purchase completed successfully",
        item: result.item
      });
    } catch (error: any) {
      console.error("Error processing purchase:", error);
      res.status(500).json({ error: error.message || "Failed to process purchase" });
    }
  });

  app.get("/api/market/my-listings", async (req, res) => {
    try {
      const userId = 1; // Demo user
      const listings = await storage.getUserMarketListings(userId);
      res.json(listings);
    } catch (error) {
      console.error("Error fetching user listings:", error);
      res.status(500).json({ error: "Failed to fetch listings" });
    }
  });

  app.delete("/api/market/listings/:listingId", async (req, res) => {
    try {
      const listingId = parseInt(req.params.listingId);
      const userId = 1; // Demo user

      await storage.cancelMarketListing(listingId, userId);
      
      res.json({ 
        success: true, 
        message: "Listing cancelled successfully" 
      });
    } catch (error: any) {
      console.error("Error cancelling listing:", error);
      res.status(500).json({ error: error.message || "Failed to cancel listing" });
    }
  });

  // Additional Admin API routes for modular admin system
  
  // Analytics endpoints
  app.get("/api/admin/analytics", requireAdminAuth, async (req, res) => {
    try {
      const timeRange = req.query.timeRange || "7d";
      const analytics = {
        totalRevenue: 25890,
        revenueChange: 12.5,
        totalUsers: 1248,
        userChange: 8.3,
        boxesOpened: 5432,
        boxesChange: 15.7,
        activeSessions: 89,
        sessionChange: -2.1,
        onlineUsers: 45,
        activeBattles: 12,
        pendingOrders: 8,
        todayRevenue: 1890,
        visitors: 2500,
        signups: 180,
        firstPurchase: 65,
        repeatCustomers: 42
      };
      res.json(analytics);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });

  app.get("/api/admin/analytics/top-boxes", requireAdminAuth, async (req, res) => {
    try {
      const topBoxes = [
        { name: "Supreme Collection", opens: 1250, revenue: 8900, growth: 15.2 },
        { name: "Tech Gadgets", opens: 890, revenue: 6200, growth: 8.7 },
        { name: "Luxury Watches", opens: 640, revenue: 4500, growth: 12.3 },
        { name: "Gaming Gear", opens: 520, revenue: 3800, growth: 5.9 },
        { name: "Fashion Items", opens: 480, revenue: 3200, growth: 9.1 }
      ];
      res.json(topBoxes);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch top boxes" });
    }
  });

  app.get("/api/admin/analytics/user-activity", requireAdminAuth, async (req, res) => {
    try {
      const userActivity = [
        { username: "Player_2024", action: "Opened Supreme Box", timestamp: "2 min ago" },
        { username: "GameMaster", action: "Won battle vs Player_123", timestamp: "5 min ago" },
        { username: "LootHunter", action: "Claimed achievement", timestamp: "8 min ago" },
        { username: "CaseOpener", action: "Deposited $50", timestamp: "12 min ago" },
        { username: "ProGamer", action: "Started battle", timestamp: "15 min ago" }
      ];
      res.json(userActivity);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch user activity" });
    }
  });

  // Battle system endpoints
  app.get("/api/admin/battles", requireAdminAuth, async (req, res) => {
    try {
      const battles = [
        {
          id: 1,
          name: "Supreme Showdown",
          description: "Battle for rare Supreme items",
          maxPlayers: 4,
          currentPlayers: 3,
          entryFee: 25.00,
          prizePool: 90.00,
          duration: 30,
          status: "active",
          rules: "Standard battle rules apply"
        },
        {
          id: 2,
          name: "Tech Battle",
          description: "Fight for the latest gadgets",
          maxPlayers: 2,
          currentPlayers: 2,
          entryFee: 15.00,
          prizePool: 28.00,
          duration: 20,
          status: "completed",
          rules: "Winner takes all"
        }
      ];
      res.json(battles);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch battles" });
    }
  });

  app.get("/api/admin/battle-stats", requireAdminAuth, async (req, res) => {
    try {
      const battleStats = {
        activeBattles: 12,
        totalPlayers: 89,
        totalPrizePool: 2450,
        avgDuration: 25
      };
      res.json(battleStats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch battle stats" });
    }
  });

  // User management endpoints
  app.get("/api/admin/users", requireAdminAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  app.get("/api/admin/user-stats", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const userStats = {
        totalUsers: users.length,
        activeUsers: users.filter(u => u.usdBalance && parseFloat(u.usdBalance) > 0).length,
        bannedUsers: 0,
        totalRevenue: users.reduce((sum, u) => sum + (parseFloat(u.usdBalance || "0")), 0)
      };
      res.json(userStats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch user stats" });
    }
  });

  // Content management endpoints
  app.get("/api/admin/blogs", async (req, res) => {
    try {
      const blogs = [
        {
          id: 1,
          title: "Welcome to RollingDrop",
          content: "Discover the best mystery boxes...",
          status: "published",
          category: "news",
          createdAt: new Date().toISOString()
        }
      ];
      res.json(blogs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch blogs" });
    }
  });

  app.get("/api/admin/faqs", async (req, res) => {
    try {
      const faqs = [
        {
          id: 1,
          title: "How do mystery boxes work?",
          content: "Mystery boxes contain random items...",
          status: "published",
          category: "general",
          createdAt: new Date().toISOString()
        }
      ];
      res.json(faqs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch FAQs" });
    }
  });

  app.get("/api/admin/sliders", async (req, res) => {
    try {
      const sliders = [
        {
          id: 1,
          title: "New Supreme Collection",
          content: "Check out our latest Supreme items",
          status: "published",
          imageUrl: "https://example.com/slider1.jpg",
          order: 1,
          createdAt: new Date().toISOString()
        }
      ];
      res.json(sliders);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch sliders" });
    }
  });

  // Legal Pages Management API
  app.get("/api/admin/legal-pages", requireAdminAuth, async (req, res) => {
    try {
      const legalPages = await storage.getAllLegalPages();
      res.json(legalPages);
    } catch (error) {
      console.error("Error fetching legal pages:", error);
      res.status(500).json({ error: "Failed to fetch legal pages" });
    }
  });

  app.get("/api/admin/legal-pages/:id", requireAdminAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const pages = await storage.getAllLegalPages();
      const page = pages.find(p => p.id === id);
      
      if (!page) {
        return res.status(404).json({ error: "Legal page not found" });
      }
      
      res.json(page);
    } catch (error) {
      console.error("Error fetching legal page:", error);
      res.status(500).json({ error: "Failed to fetch legal page" });
    }
  });

  app.post("/api/admin/legal-pages", requireAdminAuth, async (req, res) => {
    try {
      const { slug, title, content, metaDescription, status } = req.body;
      
      if (!slug || !title || !content) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      const legalPage = await storage.createLegalPage({
        slug,
        title,
        content,
        metaDescription,
        status: status || "published",
        lastUpdatedBy: 1 // Admin user ID
      });

      res.json(legalPage);
    } catch (error) {
      console.error("Error creating legal page:", error);
      res.status(500).json({ error: "Failed to create legal page" });
    }
  });

  app.put("/api/admin/legal-pages/:id", requireAdminAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { slug, title, content, metaDescription, status } = req.body;
      
      const updatedPage = await storage.updateLegalPage(id, {
        slug,
        title,
        content,
        metaDescription,
        status
      }, 1); // Admin user ID

      if (!updatedPage) {
        return res.status(404).json({ error: "Legal page not found" });
      }

      res.json(updatedPage);
    } catch (error) {
      console.error("Error updating legal page:", error);
      res.status(500).json({ error: "Failed to update legal page" });
    }
  });

  app.delete("/api/admin/legal-pages/:id", requireAdminAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteLegalPage(id);
      
      if (!success) {
        return res.status(404).json({ error: "Legal page not found" });
      }

      res.json({ message: "Legal page deleted successfully" });
    } catch (error) {
      console.error("Error deleting legal page:", error);
      res.status(500).json({ error: "Failed to delete legal page" });
    }
  });

  // Get all legal pages (for admin content management)
  app.get("/api/legal-pages", async (req, res) => {
    try {
      const pages = await storage.getAllLegalPages();
      res.json(pages);
    } catch (error) {
      console.error("Error fetching legal pages:", error);
      res.status(500).json({ error: "Failed to fetch legal pages" });
    }
  });

  // Public legal pages API (for frontend consumption)
  app.get("/api/legal/:slug", async (req, res) => {
    try {
      const slug = req.params.slug;
      const page = await storage.getLegalPageBySlug(slug);
      
      if (!page || page.status !== "published") {
        return res.status(404).json({ error: "Page not found" });
      }

      res.json(page);
    } catch (error) {
      console.error("Error fetching legal page:", error);
      res.status(500).json({ error: "Failed to fetch legal page" });
    }
  });

  // Battle System API Endpoints
  app.get("/api/battles", async (req, res) => {
    try {
      const battles = await storage.getActiveBattles();
      res.json(battles);
    } catch (error) {
      console.error("Error fetching battles:", error);
      res.status(500).json({ error: "Failed to fetch battles" });
    }
  });

  app.post("/api/battles", async (req, res) => {
    try {
      const battleData = {
        boxId: req.body.boxId,
        createdBy: 1, // Demo user ID
        maxPlayers: req.body.maxPlayers || 2,
        entryFee: req.body.entryFee,
        totalRounds: req.body.totalRounds || 3
      };
      
      const battle = await storage.createBattle(battleData);
      
      // Auto-join creator as first participant
      await storage.joinBattle(battle.id, 1);
      
      // Broadcast new battle to all clients
      wss.clients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'battle_created',
            battle
          }));
        }
      });
      
      res.json(battle);
    } catch (error) {
      console.error("Error creating battle:", error);
      res.status(500).json({ error: "Failed to create battle" });
    }
  });

  app.post("/api/battles/:id/join", async (req, res) => {
    try {
      const battleId = parseInt(req.params.id);
      const userId = 1; // Demo user ID
      
      const participation = await storage.joinBattle(battleId, userId);
      const battle = await storage.getBattle(battleId);
      
      // Check if battle is full and start it
      if (battle.participants && battle.participants.length >= battle.maxPlayers) {
        await storage.updateBattleStatus(battleId, 'active');
        
        // Broadcast battle start
        const updatedBattle = await storage.getBattle(battleId);
        wss.clients.forEach(client => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'battle_started',
              battleId,
              battle: updatedBattle
            }));
          }
        });
      }
      
      res.json(participation);
    } catch (error) {
      console.error("Error joining battle:", error);
      res.status(500).json({ error: "Failed to join battle" });
    }
  });

  app.get("/api/battles/:id", async (req, res) => {
    try {
      const battleId = parseInt(req.params.id);
      const battle = await storage.getBattle(battleId);
      res.json(battle);
    } catch (error) {
      console.error("Error fetching battle:", error);
      res.status(500).json({ error: "Failed to fetch battle" });
    }
  });

  // Profile endpoints
  app.post("/api/profile/change-password", async (req, res) => {
    try {
      const { currentPassword, newPassword } = req.body;
      const userId = 1; // Demo user
      
      // In a real application, verify current password here
      // For demo purposes, we'll just simulate success
      
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  app.post("/api/profile/update", async (req, res) => {
    try {
      const { username, email, phoneNumber, country, shippingAddress } = req.body;
      const userId = 1; // Demo user
      
      await storage.updateUser(userId, { username });
      
      res.json({ message: "Profile updated successfully" });
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  app.get("/api/profile/missions", async (req, res) => {
    try {
      // Demo missions data
      const missions = [
        {
          id: 1,
          title: "Daily Case Opener",
          description: "Open 5 cases today",
          progress: 2,
          target: 5,
          reward: 100,
          completed: false,
          claimed: false,
          type: "daily"
        },
        {
          id: 2,
          title: "Lucky Winner",
          description: "Win an epic item",
          progress: 0,
          target: 1,
          reward: 500,
          completed: false,
          claimed: false,
          type: "daily"
        },
        {
          id: 3,
          title: "Spender",
          description: "Spend $50 this week",
          progress: 25,
          target: 50,
          reward: 200,
          completed: false,
          claimed: false,
          type: "weekly"
        }
      ];
      
      res.json(missions);
    } catch (error) {
      console.error("Error fetching missions:", error);
      res.status(500).json({ message: "Failed to fetch missions" });
    }
  });

  app.get("/api/profile/payments", async (req, res) => {
    try {
      // Demo payment history
      const payments = [
        {
          id: 1,
          type: "deposit",
          amount: 100,
          method: "Credit Card",
          status: "completed",
          date: new Date().toISOString(),
          transactionId: "TXN123456789"
        },
        {
          id: 2,
          type: "withdrawal",
          amount: 50,
          method: "PayPal",
          status: "completed", 
          date: new Date(Date.now() - 86400000).toISOString(),
          transactionId: "TXN987654321"
        }
      ];
      
      res.json(payments);
    } catch (error) {
      console.error("Error fetching payment history:", error);
      res.status(500).json({ message: "Failed to fetch payment history" });
    }
  });

  // Self-exclusion endpoints
  app.get("/api/self-exclusion/status", async (req, res) => {
    try {
      // Demo exclusion status - normally would check database
      const exclusionStatus = {
        isActive: false,
        type: null,
        duration: null,
        startDate: null,
        endDate: null,
        reason: null
      };
      
      res.json(exclusionStatus);
    } catch (error) {
      console.error("Error fetching self-exclusion status:", error);
      res.status(500).json({ message: "Failed to fetch self-exclusion status" });
    }
  });

  app.post("/api/self-exclusion/activate", async (req, res) => {
    try {
      const { type, duration, reason, password } = req.body;
      const userId = 1; // Demo user
      
      // In real implementation, verify password and create exclusion record
      
      res.json({ 
        message: "Self-exclusion activated successfully",
        exclusionId: Date.now()
      });
    } catch (error) {
      console.error("Error activating self-exclusion:", error);
      res.status(500).json({ message: "Failed to activate self-exclusion" });
    }
  });

  // Vault endpoints
  app.get("/api/vault/balance", async (req, res) => {
    try {
      // Demo vault data
      const vaultBalance = {
        balance: 0,
        lockedAmount: 0,
        lockEndTime: null,
        lockDuration: null
      };
      
      res.json(vaultBalance);
    } catch (error) {
      console.error("Error fetching vault balance:", error);
      res.status(500).json({ message: "Failed to fetch vault balance" });
    }
  });

  app.post("/api/vault/deposit", async (req, res) => {
    try {
      const { amount, lockDuration } = req.body;
      const userId = 1; // Demo user
      
      // In real implementation, deduct from user balance and add to vault
      
      res.json({ 
        message: "Deposit successful",
        newVaultBalance: amount,
        lockEndTime: lockDuration ? new Date(Date.now() + lockDuration * 60000).toISOString() : null
      });
    } catch (error) {
      console.error("Error processing vault deposit:", error);
      res.status(500).json({ message: "Failed to process deposit" });
    }
  });

  app.post("/api/vault/withdraw", async (req, res) => {
    try {
      const { amount } = req.body;
      const userId = 1; // Demo user
      
      // In real implementation, verify vault balance and transfer to user balance
      
      res.json({ 
        message: "Withdrawal successful",
        newVaultBalance: 0
      });
    } catch (error) {
      console.error("Error processing vault withdrawal:", error);
      res.status(500).json({ message: "Failed to process withdrawal" });
    }
  });

  app.get("/api/vault/transactions", async (req, res) => {
    try {
      // Demo transaction history
      const transactions = [
        {
          id: 1,
          type: "deposit",
          amount: 100,
          timestamp: new Date().toISOString(),
          status: "completed"
        }
      ];
      
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching vault transactions:", error);
      res.status(500).json({ message: "Failed to fetch transactions" });
    }
  });

  // Fairness proof endpoints
  app.get("/api/fairness/my-proofs", async (req, res) => {
    try {
      const userId = 1; // Demo user
      const proofs = await storage.getUserFairnessProofs(userId);
      res.json(proofs);
    } catch (error) {
      console.error("Error fetching fairness proofs:", error);
      res.status(500).json({ message: "Failed to fetch fairness proofs" });
    }
  });

  app.post("/api/fairness/reveal/:id", async (req, res) => {
    try {
      const proofId = parseInt(req.params.id);
      const revealedProof = await storage.revealFairnessProof(proofId);
      if (!revealedProof) {
        return res.status(404).json({ message: "Fairness proof not found" });
      }
      res.json(revealedProof);
    } catch (error) {
      console.error("Error revealing fairness proof:", error);
      res.status(500).json({ message: "Failed to reveal fairness proof" });
    }
  });

  app.post("/api/fairness/verify-manual", async (req, res) => {
    try {
      const { serverSeed, clientSeed, nonce, combinedHash, resultHash } = req.body;
      
      // Verify the proof manually using the fairness system
      const expectedCombinedHash = FairnessSystem.createCombinedHash(
        serverSeed,
        clientSeed,
        parseInt(nonce)
      );
      
      const isValid = expectedCombinedHash === combinedHash;
      
      res.json({ valid: isValid });
    } catch (error) {
      console.error("Error verifying manual proof:", error);
      res.status(500).json({ message: "Failed to verify proof" });
    }
  });

  app.get("/api/fairness/proof/:id", async (req, res) => {
    try {
      const proofId = parseInt(req.params.id);
      const proof = await storage.getFairnessProof(proofId);
      if (!proof) {
        return res.status(404).json({ message: "Fairness proof not found" });
      }
      res.json(proof);
    } catch (error) {
      console.error("Error fetching fairness proof:", error);
      res.status(500).json({ message: "Failed to fetch fairness proof" });
    }
  });

  // Favorites endpoints
  app.post('/api/favorites/:boxId', async (req: any, res) => {
    try {
      const userId = 1; // Demo user ID
      const boxId = parseInt(req.params.boxId);
      
      const favorite = await storage.addToFavorites(userId, boxId);
      res.json(favorite);
    } catch (error) {
      console.error('Error adding to favorites:', error);
      res.status(500).json({ message: 'Failed to add to favorites' });
    }
  });

  app.delete('/api/favorites/:boxId', async (req: any, res) => {
    try {
      const userId = 1; // Demo user ID
      const boxId = parseInt(req.params.boxId);
      
      await storage.removeFromFavorites(userId, boxId);
      res.json({ success: true });
    } catch (error) {
      console.error('Error removing from favorites:', error);
      res.status(500).json({ message: 'Failed to remove from favorites' });
    }
  });

  app.get('/api/favorites', async (req: any, res) => {
    try {
      const userId = 1; // Demo user ID
      const favorites = await storage.getUserFavorites(userId);
      res.json(favorites);
    } catch (error) {
      console.error('Error fetching favorites:', error);
      res.status(500).json({ message: 'Failed to fetch favorites' });
    }
  });

  // Whitelabel Sites Management Routes
  app.get("/api/admin/whitelabel-sites", requireAdminAuth, async (req, res) => {
    try {
      const sites = await storage.getAllWhitelabelSites();
      res.json(sites);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch whitelabel sites" });
    }
  });

  app.get("/api/admin/whitelabel-sites/:id", requireAdminAuth, async (req, res) => {
    try {
      const whitelabelId = req.params.id;
      const site = await storage.getWhitelabelSiteByWhitelabelId(whitelabelId);
      if (!site) {
        return res.status(404).json({ message: "Site not found" });
      }
      res.json(site);
    } catch (error: any) {
      console.error("Error fetching whitelabel site:", error);
      res.status(500).json({ message: "Failed to fetch whitelabel site" });
    }
  });

  app.post("/api/admin/whitelabel-sites", requireAdminAuth, async (req, res) => {
    try {
      const siteData = req.body;
      const site = await storage.createWhitelabelSite(siteData);
      res.json(site);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to create whitelabel site" });
    }
  });

  app.put("/api/admin/whitelabel-sites/:id", requireAdminAuth, async (req, res) => {
    try {
      const whitelabelId = req.params.id;
      const siteData = req.body;
      
      // Find the site by whitelabel ID first
      const existingSite = await storage.getWhitelabelSiteByWhitelabelId(whitelabelId);
      if (!existingSite) {
        return res.status(404).json({ message: "Site not found" });
      }
      
      const site = await storage.updateWhitelabelSite(existingSite.id, siteData);
      if (!site) {
        return res.status(404).json({ message: "Site not found" });
      }
      res.json(site);
    } catch (error: any) {
      console.error("Error updating whitelabel site:", error);
      res.status(500).json({ message: "Failed to update whitelabel site" });
    }
  });

  app.delete("/api/admin/whitelabel-sites/:id", requireAdminAuth, async (req, res) => {
    try {
      const siteId = parseInt(req.params.id);
      await storage.deleteWhitelabelSite(siteId);
      res.json({ message: "Site deleted successfully" });
    } catch (error: any) {
      res.status(500).json({ message: "Failed to delete whitelabel site" });
    }
  });

  // Partner Management Routes
  app.get("/api/admin/partners", requireAdminAuth, async (req, res) => {
    try {
      const partners = await storage.getAllPartners();
      res.json(partners);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch partners" });
    }
  });

  app.post("/api/admin/partners", requireAdminAuth, async (req, res) => {
    try {
      const partnerData = req.body;
      const crypto = require('crypto');
      partnerData.apiKey = crypto.randomBytes(32).toString('hex');
      const partner = await storage.createPartner(partnerData);
      res.json(partner);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to create partner" });
    }
  });

  app.put("/api/admin/partners/:id", requireAdminAuth, async (req, res) => {
    try {
      const partnerId = parseInt(req.params.id);
      const partnerData = req.body;
      const partner = await storage.updatePartner(partnerId, partnerData);
      if (!partner) {
        return res.status(404).json({ message: "Partner not found" });
      }
      res.json(partner);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to update partner" });
    }
  });

  app.delete("/api/admin/partners/:id", requireAdminAuth, async (req, res) => {
    try {
      const partnerId = parseInt(req.params.id);
      await storage.deletePartner(partnerId);
      res.json({ message: "Partner deleted successfully" });
    } catch (error: any) {
      res.status(500).json({ message: "Failed to delete partner" });
    }
  });

  app.post("/api/admin/partners/:id/regenerate-api-key", requireAdminAuth, async (req, res) => {
    try {
      const partnerId = parseInt(req.params.id);
      const crypto = require('crypto');
      const newApiKey = crypto.randomBytes(32).toString('hex');
      const partner = await storage.updatePartner(partnerId, { apiKey: newApiKey });
      if (!partner) {
        return res.status(404).json({ message: "Partner not found" });
      }
      res.json(partner);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to regenerate API key" });
    }
  });

  app.get("/api/admin/partner-stats", requireAdminAuth, async (req, res) => {
    try {
      const stats = await storage.getPartnerStats();
      res.json(stats);
    } catch (error: any) {
      res.status(500).json({ message: "Failed to fetch partner stats" });
    }
  });

  const httpServer = createServer(app);
  
  // Chat system state
  const chatClients = new Map<WebSocket, { username: string; userId?: number }>();
  const onlineUsers = new Set<string>();
  
  // Set up WebSocket server for real-time battle updates
  const wss = new WebSocketServer({ 
    server: httpServer, 
    path: '/ws' 
  });
  
  // Set up WebSocket server for live chat
  const chatWss = new WebSocketServer({ 
    server: httpServer, 
    path: '/ws/chat' 
  });

  // Chat WebSocket handlers
  const broadcastToChat = (message: any, excludeClient?: WebSocket) => {
    chatWss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN && client !== excludeClient) {
        client.send(JSON.stringify(message));
      }
    });
  };

  const broadcastOnlineUsers = () => {
    const users = Array.from(onlineUsers);
    broadcastToChat({
      type: 'online_users',
      users
    });
  };

  chatWss.on('connection', (ws) => {
    console.log('Client connected to chat WebSocket');
    
    ws.on('message', async (message) => {
      try {
        const data = JSON.parse(message.toString());
        
        switch (data.type) {
          case 'join':
            if (data.username) {
              chatClients.set(ws, { username: data.username });
              onlineUsers.add(data.username);
              
              broadcastToChat({
                type: 'user_joined',
                username: data.username
              }, ws);
              
              broadcastOnlineUsers();
            }
            break;
            
          case 'message':
            if (data.message && data.username) {
              const chatMessage = {
                id: `msg_${Date.now()}_${Math.random()}`,
                type: 'message',
                username: data.username,
                message: data.message,
                timestamp: new Date().toISOString()
              };
              
              broadcastToChat(chatMessage);
            }
            break;
            
          case 'opening':
            if (data.message && data.username) {
              const openingMessage = {
                id: `opening_${Date.now()}_${Math.random()}`,
                type: 'opening',
                username: data.username,
                message: data.message,
                timestamp: new Date().toISOString(),
                data: data.data
              };
              
              broadcastToChat(openingMessage);
            }
            break;
            
          case 'reaction':
            if (data.emoji && data.messageId && data.username) {
              const reactionMessage = {
                id: `reaction_${Date.now()}_${Math.random()}`,
                type: 'reaction',
                username: data.username,
                message: `reacted ${data.emoji} to a message`,
                timestamp: new Date().toISOString(),
                data: {
                  emoji: data.emoji,
                  messageId: data.messageId
                }
              };
              
              broadcastToChat(reactionMessage);
            }
            break;
        }
      } catch (error) {
        console.error('Chat WebSocket message error:', error);
      }
    });
    
    ws.on('close', () => {
      const clientData = chatClients.get(ws);
      if (clientData) {
        onlineUsers.delete(clientData.username);
        chatClients.delete(ws);
        
        broadcastToChat({
          type: 'user_left',
          username: clientData.username
        });
        
        broadcastOnlineUsers();
      }
      console.log('Client disconnected from chat WebSocket');
    });
  });

  wss.on('connection', (ws) => {
    console.log('Client connected to WebSocket');
    
    ws.on('message', async (message) => {
      try {
        const data = JSON.parse(message.toString());
        
        if (data.type === 'join_battle_room') {
          (ws as any).battleId = data.battleId;
        }
        
        if (data.type === 'open_box' && (ws as any).battleId) {
          // Handle box opening in battle
          const battleId = (ws as any).battleId;
          const userId = data.userId || 1;
          
          // Simulate box opening
          const result = await storage.openBox(data.boxId, userId);
          
          // Broadcast to all clients in this battle
          wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN && (client as any).battleId === battleId) {
              client.send(JSON.stringify({
                type: 'box_opened',
                battleId,
                userId,
                result
              }));
            }
          });
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });
    
    ws.on('close', () => {
      console.log('Client disconnected from WebSocket');
    });
  });

  // =====================================
  // WHITELABEL MANAGEMENT ROUTES
  // =====================================
  
  // Get all whitelabel sites
  app.get('/api/admin/whitelabels', requireAdminAuth, async (req, res) => {
    try {
      const whitelabels = await whitelabelManager.getAllWhitelabelSites();
      res.json(whitelabels);
    } catch (error) {
      console.error('Error fetching whitelabels:', error);
      res.status(500).json({ error: 'Failed to fetch whitelabels' });
    }
  });

  // Create new whitelabel site
  app.post('/api/admin/whitelabels', requireAdminAuth, async (req, res) => {
    try {
      const validatedData = insertWhitelabelSiteSchema.parse(req.body);
      const whitelabel = await whitelabelManager.createWhitelabelSite(validatedData);
      res.status(201).json(whitelabel);
    } catch (error) {
      console.error('Error creating whitelabel:', error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: 'Invalid data', details: error.errors });
      } else {
        res.status(500).json({ error: 'Failed to create whitelabel' });
      }
    }
  });

  // Get specific whitelabel site
  app.get('/api/admin/whitelabels/:whitelabelId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const whitelabel = await whitelabelManager.getWhitelabelSite(whitelabelId);
      
      if (!whitelabel) {
        return res.status(404).json({ error: 'Whitelabel not found' });
      }
      
      res.json(whitelabel);
    } catch (error) {
      console.error('Error fetching whitelabel:', error);
      res.status(500).json({ error: 'Failed to fetch whitelabel' });
    }
  });

  // Deploy whitelabel site
  app.post('/api/admin/whitelabels/:whitelabelId/deploy', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const { domain, subdomain, environmentType = 'production' } = req.body;
      
      if (!domain && !subdomain) {
        return res.status(400).json({ error: 'Either domain or subdomain is required' });
      }
      
      const deployment = await whitelabelManager.deployWhitelabelSite(whitelabelId, {
        domain,
        subdomain,
        environmentType
      });
      
      res.status(201).json(deployment);
    } catch (error) {
      console.error('Error deploying whitelabel:', error);
      res.status(500).json({ error: error.message || 'Failed to deploy whitelabel' });
    }
  });

  // Update whitelabel configuration (hot-reload capable)
  app.patch('/api/admin/whitelabels/:whitelabelId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const { brandingConfig, themeConfig, featureConfig, seoConfig } = req.body;
      
      const updatedWhitelabel = await whitelabelManager.updateWhitelabelConfig(whitelabelId, {
        brandingConfig,
        themeConfig,
        featureConfig,
        seoConfig
      });
      
      res.json(updatedWhitelabel);
    } catch (error) {
      console.error('Error updating whitelabel:', error);
      res.status(500).json({ error: error.message || 'Failed to update whitelabel' });
    }
  });

  // Get deployment history
  app.get('/api/admin/whitelabels/:whitelabelId/deployments', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const deployments = await whitelabelManager.getDeploymentHistory(whitelabelId);
      res.json(deployments);
    } catch (error) {
      console.error('Error fetching deployment history:', error);
      res.status(500).json({ error: 'Failed to fetch deployment history' });
    }
  });

  // Delete/suspend whitelabel site
  app.delete('/api/admin/whitelabels/:whitelabelId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      await whitelabelManager.deleteWhitelabelSite(whitelabelId);
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting whitelabel:', error);
      res.status(500).json({ error: error.message || 'Failed to delete whitelabel' });
    }
  });

  // Get available whitelabel templates
  app.get('/api/admin/whitelabel-templates', requireAdminAuth, async (req, res) => {
    try {
      const templates = await whitelabelManager.getTemplates();
      res.json(templates);
    } catch (error) {
      console.error('Error fetching templates:', error);
      res.status(500).json({ error: 'Failed to fetch templates' });
    }
  });

  // Create whitelabel from template
  app.post('/api/admin/whitelabels/from-template/:templateId', requireAdminAuth, async (req, res) => {
    try {
      const { templateId } = req.params;
      const whitelabelData = insertWhitelabelSiteSchema.parse(req.body);
      
      const whitelabel = await whitelabelManager.createFromTemplate(
        parseInt(templateId), 
        whitelabelData
      );
      
      res.status(201).json(whitelabel);
    } catch (error) {
      console.error('Error creating whitelabel from template:', error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ error: 'Invalid data', details: error.errors });
      } else {
        res.status(500).json({ error: error.message || 'Failed to create whitelabel from template' });
      }
    }
  });

  // Whitelabel-specific content management routes
  
  // Get boxes associated with a specific whitelabel
  app.get('/api/admin/whitelabel-sites/:whitelabelId/boxes', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const boxes = await storage.getWhitelabelBoxes(whitelabelId);
      res.json(boxes);
    } catch (error) {
      console.error('Error fetching whitelabel boxes:', error);
      res.status(500).json({ error: 'Failed to fetch boxes' });
    }
  });

  // Add existing box to whitelabel (creates association, doesn't duplicate box)
  app.post('/api/admin/whitelabel-sites/:whitelabelId/boxes/:boxId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId, boxId } = req.params;
      const config = req.body; // enabled, featured, customPrice, etc.
      
      const association = await storage.addBoxToWhitelabel(whitelabelId, parseInt(boxId), config);
      res.status(201).json(association);
    } catch (error) {
      console.error('Error adding box to whitelabel:', error);
      res.status(500).json({ error: 'Failed to add box to whitelabel' });
    }
  });

  // Remove box from whitelabel (removes association only, preserves box in main inventory)
  app.delete('/api/admin/whitelabel-sites/:whitelabelId/boxes/:boxId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId, boxId } = req.params;
      
      const removed = await storage.removeBoxFromWhitelabel(whitelabelId, parseInt(boxId));
      if (removed) {
        res.status(204).send();
      } else {
        res.status(404).json({ error: 'Box association not found' });
      }
    } catch (error) {
      console.error('Error removing box from whitelabel:', error);
      res.status(500).json({ error: 'Failed to remove box from whitelabel' });
    }
  });

  // Update whitelabel box settings (pricing, featured status, etc.)
  app.put('/api/admin/whitelabel-sites/:whitelabelId/boxes/:boxId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId, boxId } = req.params;
      const updates = req.body;
      
      const updated = await storage.updateWhitelabelBox(whitelabelId, parseInt(boxId), updates);
      if (updated) {
        res.json(updated);
      } else {
        res.status(404).json({ error: 'Box association not found' });
      }
    } catch (error) {
      console.error('Error updating whitelabel box:', error);
      res.status(500).json({ error: 'Failed to update whitelabel box' });
    }
  });

  // Update box for specific whitelabel
  app.patch('/api/admin/whitelabel-sites/:whitelabelId/boxes/:boxId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId, boxId } = req.params;
      const { enabled, ...updateData } = req.body;
      
      // Update the box with new data
      const updatedBox = await storage.updateBox(parseInt(boxId), { 
        featured: enabled,
        ...updateData 
      });
      res.json(updatedBox);
    } catch (error) {
      console.error('Error updating whitelabel box:', error);
      res.status(500).json({ error: 'Failed to update box' });
    }
  });

  // Delete box for specific whitelabel
  app.delete('/api/admin/whitelabel-sites/:whitelabelId/boxes/:boxId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId, boxId } = req.params;
      await storage.deleteBox(parseInt(boxId));
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting whitelabel box:', error);
      res.status(500).json({ error: 'Failed to delete box' });
    }
  });

  // Get battles for a specific whitelabel
  app.get('/api/admin/whitelabel-sites/:whitelabelId/battles', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const battles = await storage.getBattlesByWhitelabel(whitelabelId);
      res.json(battles);
    } catch (error) {
      console.error('Error fetching whitelabel battles:', error);
      res.status(500).json({ error: 'Failed to fetch battles' });
    }
  });

  // Create battle for specific whitelabel
  app.post('/api/admin/whitelabel-sites/:whitelabelId/battles', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId } = req.params;
      const battleData = { ...req.body, whitelabelId };
      const battle = await storage.createBattle(battleData);
      res.status(201).json(battle);
    } catch (error) {
      console.error('Error creating whitelabel battle:', error);
      res.status(500).json({ error: 'Failed to create battle' });
    }
  });

  // Delete battle for specific whitelabel
  app.delete('/api/admin/whitelabel-sites/:whitelabelId/battles/:battleId', requireAdminAuth, async (req, res) => {
    try {
      const { whitelabelId, battleId } = req.params;
      await storage.deleteBattle(parseInt(battleId));
      res.json({ success: true });
    } catch (error) {
      console.error('Error deleting whitelabel battle:', error);
      res.status(500).json({ error: 'Failed to delete battle' });
    }
  });

  return httpServer;
}
